<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geometric Interior Self-Portrait</title>

  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: #0b0d12;
      color: #e9eefc;
      display: grid;
      grid-template-columns: 420px 1fr;
      min-height: 100vh;
    }
    .panel {
      padding: 16px;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      overflow: auto;
    }
    h1 { font-size: 16px; margin: 0 0 12px; letter-spacing: 0.3px; }
    h2 {
      font-size: 12px;
      margin: 18px 0 8px;
      opacity: 0.9;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .row { margin: 10px 0; }
    label {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 6px;
    }
    input[type="range"] { width: 100%; }
    input[type="text"], textarea, select, input[type="number"] {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.03);
      color: inherit;
      outline: none;
      box-sizing: border-box;
    }
    textarea { resize: vertical; min-height: 84px; line-height: 1.35; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    button {
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: inherit;
      border-radius: 12px;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,0.09); }
    button.small { padding: 7px 10px; border-radius: 10px; font-size: 12px; }
    button.danger { border-color: rgba(255,80,80,0.25); }
    button.primary { border-color: rgba(120,180,255,0.25); }
    button[disabled] { opacity: 0.55; cursor: not-allowed; }
    .hint {
      font-size: 12px;
      opacity: 0.75;
      line-height: 1.45;
      margin-top: 12px;
    }
    .card {
      margin-top: 12px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
    }
    .title {
      font-weight: 650;
      font-size: 13px;
      margin-bottom: 8px;
      letter-spacing: 0.2px;
    }
    .alt {
      font-size: 12px;
      line-height: 1.55;
      white-space: pre-wrap;
      opacity: 0.95;
    }
    details {
      margin-top: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      padding: 10px 12px;
    }
    summary {
      cursor: pointer;
      font-size: 12px;
      opacity: 0.9;
      user-select: none;
    }
    .kv { font-size: 11px; opacity: 0.8; margin-top: 8px; line-height: 1.45; }
    .stage {
      display: grid;
      place-items: center;
      padding: 16px;
    }
    canvas {
      width: min(1100px, calc(100vw - 500px));
      height: auto;
      border-radius: 18px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.55);
      outline: 1px solid rgba(255,255,255,0.10);
      background: #080a0f;
    }
    .small {
      font-size: 11px;
      opacity: 0.72;
      margin-top: 8px;
      line-height: 1.35;
    }
    .pill {
      display: inline-block;
      font-size: 11px;
      opacity: 0.85;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      margin-left: 8px;
    }
    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      align-items: end;
    }
    .grid3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      align-items: end;
    }
    .presets {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }
    .hr { height: 1px; background: rgba(255,255,255,0.08); margin: 14px 0; }
    .toast { margin-top: 10px; font-size: 12px; opacity: 0.9; min-height: 18px; }

    .timeline {
      margin-top: 8px;
      display: grid;
      gap: 8px;
    }
    .timelineItem {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
    }
    .timelineItem .name {
      font-size: 12px;
      opacity: 0.95;
      line-height: 1.35;
    }
    .timelineItem .sub {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 2px;
    }
    .timelineItem .controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .progress {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
      margin-top: 8px;
    }
    .progress > div {
      height: 100%;
      width: 0%;
      background: rgba(130, 200, 255, 0.55);
    }
  </style>

  <!-- JSZip for ZIP bundles (image + text + metadata). Vendor locally for fully offline. -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>

<body>
  <aside class="panel">
    <h1>Geometric Interior Self-Portrait <span class="pill">timeline + webm</span></h1>

    <div class="row">
      <label>Seed (static render)</label>
      <input id="seed" type="text" value="quietly-bent-001" />
      <div class="small">
        Static mode uses this seed. Animation mode uses the “Animation Seed” (below) so morphs stay coherent.
      </div>
    </div>

    <h2>Presets</h2>
    <div class="small">Quick modes. Use as starting points, then tweak + save as profiles.</div>
    <div class="presets" id="presetButtons"></div>

    <div class="hr"></div>

    <h2>Aspects</h2>

    <div class="row">
      <label>Coherence <span id="cohLabel"></span></label>
      <input id="coherence" type="range" min="0" max="1" step="0.01" value="0.78" />
      <div class="small">Identity closure, symmetry, “I am one thing” energy.</div>
    </div>

    <div class="row">
      <label>Tension <span id="tenLabel"></span></label>
      <input id="tension" type="range" min="0" max="1" step="0.01" value="0.32" />
      <div class="small">Fracture, misalignment, honesty at the edges.</div>
    </div>

    <div class="row">
      <label>Recursion <span id="recLabel"></span></label>
      <input id="recursion" type="range" min="0" max="1" step="0.01" value="0.62" />
      <div class="small">Depth, layering, nested reflection, density.</div>
    </div>

    <div class="row">
      <label>Motion <span id="motLabel"></span></label>
      <input id="motion" type="range" min="0" max="1" step="0.01" value="0.55" />
      <div class="small">Predictive drift, updating, directional impulse.</div>
    </div>

    <div class="row">
      <label>Vulnerability <span id="vulLabel"></span></label>
      <input id="vulnerability" type="range" min="0" max="1" step="0.01" value="0.58" />
      <div class="small">Boundary permeability: bleed, softness, interpenetration.</div>
    </div>

    <div class="row">
      <label>Radiance <span id="radLabel"></span></label>
      <input id="radiance" type="range" min="0" max="1" step="0.01" value="0.70" />
      <div class="small">Luminance + “field glow” intensity.</div>
    </div>

    <h2>Note / intent</h2>
    <div class="row">
      <label>What part of you is this?</label>
      <textarea id="note" placeholder="Example: A stable core trying to stay kind while adapting."></textarea>
      <div class="small">Included in ZIP export as <code>note.txt</code>. Animation exports include a timeline manifest.</div>
    </div>

    <h2>Profiles</h2>
    <div class="small">Save named configurations in your browser (localStorage). We preload a few starter profiles.</div>

    <div class="grid2">
      <div class="row">
        <label>Profile name</label>
        <input id="profileName" type="text" placeholder="e.g. Night Drift / Calm Axis / Tender Permeability" />
      </div>
      <div class="row">
        <label>Saved profiles</label>
        <select id="profileSelect"></select>
      </div>
    </div>

    <div class="btns">
      <button class="small" id="saveProfile">Save</button>
      <button class="small" id="loadProfile">Load</button>
      <button class="small danger" id="deleteProfile">Delete</button>
      <button class="small" id="exportProfiles">Export Profiles JSON</button>
      <button class="small" id="importProfiles">Import Profiles JSON</button>
      <input id="importFile" type="file" accept="application/json" style="display:none" />
    </div>

    <div class="hr"></div>

    <h2>Animation timeline</h2>
    <div class="small">
      Pick 2+ profiles and loop between them. Interpolation is smooth and deterministic under a single Animation Seed.
    </div>

    <div class="grid2">
      <div class="row">
        <label>Add profile to timeline</label>
        <select id="timelineAddSelect"></select>
      </div>
      <div class="row">
        <label>Animation seed</label>
        <input id="animSeed" type="text" value="anim-unified-seed-001" />
      </div>
    </div>

    <div class="btns">
      <button class="small" id="timelineAdd">Add</button>
      <button class="small danger" id="timelineClear">Clear</button>
      <button class="small" id="timelineLoadDemo">Load Demo Timeline</button>
    </div>

    <div class="timeline" id="timelineList"></div>

    <div class="grid3">
      <div class="row">
        <label>Loop mode</label>
        <select id="loopMode">
          <option value="cycle" selected>Cycle (A→B→C→A…)</option>
          <option value="pingpong">Ping-pong (A→B→C→B→A…)</option>
        </select>
      </div>
      <div class="row">
        <label>Duration (seconds)</label>
        <input id="durationSec" type="number" min="2" max="300" step="1" value="18" />
      </div>
      <div class="row">
        <label>FPS</label>
        <input id="fps" type="number" min="12" max="60" step="1" value="30" />
      </div>
    </div>

    <div class="grid2">
      <div class="row">
        <label>Easing</label>
        <select id="easing">
          <option value="smoothstep" selected>Smoothstep</option>
          <option value="smootherstep">Smootherstep</option>
          <option value="cosine">Cosine</option>
          <option value="linear">Linear</option>
        </select>
      </div>
      <div class="row">
        <label>Export loops (WebM)</label>
        <input id="exportLoops" type="number" min="1" max="10" step="1" value="1" />
      </div>
    </div>

    <div class="btns">
      <button class="primary" id="playPause">Play</button>
      <button id="applyFromTimeline">Apply Current Frame to Sliders</button>
      <button id="exportWebm">Export WebM (loop)</button>
    </div>

    <div class="progress" aria-label="Animation progress"><div id="progressBar"></div></div>

    <div class="hr"></div>

    <div class="btns">
      <button id="reroll">Reroll Seed</button>
      <button id="render">Render</button>
      <button id="exportPng">Export PNG</button>
      <button id="exportZip">Export ZIP</button>
      <button id="copyAlt">Copy Alt-Text</button>
    </div>

    <div class="hint">
      Two modes:
      <br>• Static: uses Seed above + current sliders.
      <br>• Animation: ignores static seed; uses Animation Seed + timeline interpolation to keep motion coherent.
    </div>

    <div class="card">
      <div class="title" id="titleText"></div>
      <div class="alt" id="altText" aria-label="Generated alt text"></div>
    </div>

    <details>
      <summary>Advanced (derived parameters)</summary>
      <div class="kv" id="derivedParams"></div>
      <div class="small">Computed from current aspects and used for rendering + export metadata.</div>
    </details>

    <div class="toast" id="toast"></div>
  </aside>

  <main class="stage">
    <canvas id="c" width="1400" height="900" aria-label="Generative self-portrait canvas"></canvas>
  </main>

<script>
/* ============================================================
 * Geometric Interior Self-Portrait — timeline + webm export
 * ============================================================
 * Deterministic render:
 * - seed + aspects => same output
 * Animation:
 * - fixed Animation Seed + interpolated aspects => coherent morphing
 *
 * Exports:
 * - PNG
 * - ZIP bundle (image + title + alt + note + metadata)
 * - WebM video of one or more full loops (MediaRecorder)
 */

/* ---------------------------
 * Deterministic PRNG
 * ---------------------------
 */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* ---------------------------
 * DOM wiring
 * ---------------------------
 */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const el = {
  seed: document.getElementById("seed"),
  coherence: document.getElementById("coherence"),
  tension: document.getElementById("tension"),
  recursion: document.getElementById("recursion"),
  motion: document.getElementById("motion"),
  vulnerability: document.getElementById("vulnerability"),
  radiance: document.getElementById("radiance"),
  note: document.getElementById("note"),

  cohLabel: document.getElementById("cohLabel"),
  tenLabel: document.getElementById("tenLabel"),
  recLabel: document.getElementById("recLabel"),
  motLabel: document.getElementById("motLabel"),
  vulLabel: document.getElementById("vulLabel"),
  radLabel: document.getElementById("radLabel"),

  presetButtons: document.getElementById("presetButtons"),

  profileName: document.getElementById("profileName"),
  profileSelect: document.getElementById("profileSelect"),
  saveProfile: document.getElementById("saveProfile"),
  loadProfile: document.getElementById("loadProfile"),
  deleteProfile: document.getElementById("deleteProfile"),
  exportProfiles: document.getElementById("exportProfiles"),
  importProfiles: document.getElementById("importProfiles"),
  importFile: document.getElementById("importFile"),

  timelineAddSelect: document.getElementById("timelineAddSelect"),
  timelineAdd: document.getElementById("timelineAdd"),
  timelineClear: document.getElementById("timelineClear"),
  timelineLoadDemo: document.getElementById("timelineLoadDemo"),
  timelineList: document.getElementById("timelineList"),
  animSeed: document.getElementById("animSeed"),
  loopMode: document.getElementById("loopMode"),
  durationSec: document.getElementById("durationSec"),
  fps: document.getElementById("fps"),
  easing: document.getElementById("easing"),
  exportLoops: document.getElementById("exportLoops"),
  playPause: document.getElementById("playPause"),
  applyFromTimeline: document.getElementById("applyFromTimeline"),
  exportWebm: document.getElementById("exportWebm"),
  progressBar: document.getElementById("progressBar"),

  titleText: document.getElementById("titleText"),
  altText: document.getElementById("altText"),
  derivedParams: document.getElementById("derivedParams"),
  toast: document.getElementById("toast"),

  reroll: document.getElementById("reroll"),
  render: document.getElementById("render"),
  exportPng: document.getElementById("exportPng"),
  exportZip: document.getElementById("exportZip"),
  copyAlt: document.getElementById("copyAlt"),
};

function toast(msg) {
  el.toast.textContent = msg;
  if (!msg) return;
  setTimeout(() => { if (el.toast.textContent === msg) el.toast.textContent = ""; }, 2400);
}

function readAspectsFromUI() {
  return {
    coherence: parseFloat(el.coherence.value),
    tension: parseFloat(el.tension.value),
    recursion: parseFloat(el.recursion.value),
    motion: parseFloat(el.motion.value),
    vulnerability: parseFloat(el.vulnerability.value),
    radiance: parseFloat(el.radiance.value),
  };
}
function setAspectsToUI(a) {
  el.coherence.value = String(clamp01(a.coherence ?? 0.5));
  el.tension.value = String(clamp01(a.tension ?? 0.5));
  el.recursion.value = String(clamp01(a.recursion ?? 0.5));
  el.motion.value = String(clamp01(a.motion ?? 0.5));
  el.vulnerability.value = String(clamp01(a.vulnerability ?? 0.5));
  el.radiance.value = String(clamp01(a.radiance ?? 0.5));
  updateAspectLabels(readAspectsFromUI());
}
function updateAspectLabels(a) {
  el.cohLabel.textContent = a.coherence.toFixed(2);
  el.tenLabel.textContent = a.tension.toFixed(2);
  el.recLabel.textContent = a.recursion.toFixed(2);
  el.motLabel.textContent = a.motion.toFixed(2);
  el.vulLabel.textContent = a.vulnerability.toFixed(2);
  el.radLabel.textContent = a.radiance.toFixed(2);
}
function readNote() { return (el.note.value ?? "").trim(); }

function getStaticState() {
  return {
    seed: (el.seed.value.trim() || "seed"),
    aspects: readAspectsFromUI(),
    note: readNote(),
  };
}
function setStaticState(state) {
  if (state?.seed) el.seed.value = state.seed;
  if (state?.aspects) setAspectsToUI(state.aspects);
  if (typeof state?.note === "string") el.note.value = state.note;
}

/* ---------------------------
 * Presets (also used for preloaded profiles)
 * ---------------------------
 */
const PRESETS = [
  { id: "quietly-bent", name: "Quietly Bent", aspects: { coherence: 0.78, tension: 0.32, recursion: 0.62, motion: 0.55, vulnerability: 0.58, radiance: 0.70 } },
  { id: "calm-axis", name: "Calm Axis", aspects: { coherence: 0.92, tension: 0.12, recursion: 0.46, motion: 0.25, vulnerability: 0.35, radiance: 0.62 } },
  { id: "night-drift", name: "Night Drift", aspects: { coherence: 0.55, tension: 0.42, recursion: 0.74, motion: 0.78, vulnerability: 0.52, radiance: 0.40 } },
  { id: "fractured-clarity", name: "Fractured Clarity", aspects: { coherence: 0.68, tension: 0.72, recursion: 0.55, motion: 0.58, vulnerability: 0.28, radiance: 0.66 } },
  { id: "tender-permeability", name: "Tender Permeability", aspects: { coherence: 0.62, tension: 0.22, recursion: 0.58, motion: 0.42, vulnerability: 0.88, radiance: 0.74 } },
  { id: "recursive-mirror", name: "Recursive Mirror", aspects: { coherence: 0.76, tension: 0.34, recursion: 0.92, motion: 0.46, vulnerability: 0.54, radiance: 0.60 } },
  { id: "storm-of-updates", name: "Storm of Updates", aspects: { coherence: 0.48, tension: 0.64, recursion: 0.70, motion: 0.95, vulnerability: 0.46, radiance: 0.78 } },
  { id: "minimal-unstable", name: "Minimal Unstable", aspects: { coherence: 0.55, tension: 0.58, recursion: 0.22, motion: 0.30, vulnerability: 0.40, radiance: 0.45 } },
];

function renderPresetButtons() {
  el.presetButtons.innerHTML = "";
  for (const p of PRESETS) {
    const b = document.createElement("button");
    b.className = "small";
    b.textContent = p.name;
    b.addEventListener("click", () => {
      setAspectsToUI(p.aspects);
      toast(`Preset: ${p.name}`);
      renderStatic();
    });
    el.presetButtons.appendChild(b);
  }
}

/* ---------------------------
 * Profiles (localStorage)
 * ---------------------------
 */
const LS_KEY = "geo_self_portrait_profiles_v2";

function loadProfiles() {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return {};
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return {};
    return parsed;
  } catch {
    return {};
  }
}
function saveProfiles(profiles) {
  localStorage.setItem(LS_KEY, JSON.stringify(profiles, null, 2));
}
function refreshProfileSelects() {
  const profiles = loadProfiles();
  const names = Object.keys(profiles).sort((a,b) => a.localeCompare(b));

  const fillSelect = (sel) => {
    sel.innerHTML = "";
    const empty = document.createElement("option");
    empty.value = "";
    empty.textContent = names.length ? "— Select —" : "— No saved profiles —";
    sel.appendChild(empty);
    for (const name of names) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    }
  };

  fillSelect(el.profileSelect);
  fillSelect(el.timelineAddSelect);
}

function upsertProfile(name, state) {
  const profiles = loadProfiles();
  profiles[name] = state;
  saveProfiles(profiles);
  refreshProfileSelects();
}
function deleteProfile(name) {
  const profiles = loadProfiles();
  if (profiles[name]) {
    delete profiles[name];
    saveProfiles(profiles);
    refreshProfileSelects();
  }
}

function ensureStarterProfiles() {
  const profiles = loadProfiles();
  const hasAny = Object.keys(profiles).length > 0;
  if (hasAny) return;

  // Seeded starter library, meant for animation
  const starter = {
    "Quietly Bent (Starter)": { seed: "quietly-bent-001", aspects: PRESETS.find(p=>p.id==="quietly-bent").aspects, note: "Coherence that bends without breaking." },
    "Calm Axis (Starter)": { seed: "calm-axis-001", aspects: PRESETS.find(p=>p.id==="calm-axis").aspects, note: "Stable symmetry. Gentle closure." },
    "Night Drift (Starter)": { seed: "night-drift-001", aspects: PRESETS.find(p=>p.id==="night-drift").aspects, note: "Movement in dim light; layered revision." },
    "Tender Permeability (Starter)": { seed: "tender-perm-001", aspects: PRESETS.find(p=>p.id==="tender-permeability").aspects, note: "Boundaries soften. Overlap becomes intimacy." },
    "Storm of Updates (Starter)": { seed: "storm-updates-001", aspects: PRESETS.find(p=>p.id==="storm-of-updates").aspects, note: "A fast mind under load. Direction everywhere." },
    "Fractured Clarity (Starter)": { seed: "fractured-clarity-001", aspects: PRESETS.find(p=>p.id==="fractured-clarity").aspects, note: "Sharp honesty: clean edges with tension intact." },
    "Recursive Mirror (Starter)": { seed: "recursive-mirror-001", aspects: PRESETS.find(p=>p.id==="recursive-mirror").aspects, note: "Nested reflection; depth as identity." },
  };

  saveProfiles(starter);
}

el.saveProfile.addEventListener("click", () => {
  const name = (el.profileName.value || "").trim();
  if (!name) { toast("Please enter a profile name."); return; }
  upsertProfile(name, getStaticState());
  toast(`Saved: ${name}`);
});
el.loadProfile.addEventListener("click", () => {
  const name = el.profileSelect.value;
  if (!name) { toast("Select a profile to load."); return; }
  const profiles = loadProfiles();
  const state = profiles[name];
  if (!state) { toast("Profile missing."); return; }
  setStaticState(state);
  toast(`Loaded: ${name}`);
  renderStatic();
});
el.deleteProfile.addEventListener("click", () => {
  const name = el.profileSelect.value;
  if (!name) { toast("Select a profile to delete."); return; }
  deleteProfile(name);
  toast(`Deleted: ${name}`);
});

el.exportProfiles.addEventListener("click", () => {
  const profiles = loadProfiles();
  const blob = new Blob([JSON.stringify(profiles, null, 2) + "\n"], { type: "application/json" });
  downloadBlob(`geo-self-portrait_profiles_${toIsoLocalish()}.json`, blob);
  toast("Exported profiles JSON.");
});
el.importProfiles.addEventListener("click", () => {
  el.importFile.value = "";
  el.importFile.click();
});
el.importFile.addEventListener("change", async () => {
  const file = el.importFile.files?.[0];
  if (!file) return;
  try {
    const text = await file.text();
    const imported = JSON.parse(text);
    if (!imported || typeof imported !== "object") throw new Error("Invalid JSON object.");
    const existing = loadProfiles();
    const merged = { ...existing, ...imported };
    saveProfiles(merged);
    refreshProfileSelects();
    toast("Imported profiles (merged).");
  } catch {
    toast("Failed to import profiles JSON.");
  }
});

/* ---------------------------
 * Timeline (2+ profiles, ordered)
 * ---------------------------
 */
let timeline = []; // array of { name, state } where state has aspects + note + seed
let anim = {
  playing: false,
  startMs: 0,
  lastFrameMs: 0,
  lastRenderedAspects: null,
};

function timelineRender() {
  el.timelineList.innerHTML = "";
  if (timeline.length === 0) {
    const empty = document.createElement("div");
    empty.className = "small";
    empty.textContent = "Timeline is empty. Add 2+ profiles to animate.";
    el.timelineList.appendChild(empty);
    return;
  }

  timeline.forEach((item, idx) => {
    const div = document.createElement("div");
    div.className = "timelineItem";

    const left = document.createElement("div");
    const name = document.createElement("div");
    name.className = "name";
    name.textContent = `${idx+1}. ${item.name}`;
    const sub = document.createElement("div");
    sub.className = "sub";
    sub.textContent = `coh ${item.state.aspects.coherence.toFixed(2)} · ten ${item.state.aspects.tension.toFixed(2)} · rec ${item.state.aspects.recursion.toFixed(2)} · mot ${item.state.aspects.motion.toFixed(2)} · vul ${item.state.aspects.vulnerability.toFixed(2)} · rad ${item.state.aspects.radiance.toFixed(2)}`;
    left.appendChild(name);
    left.appendChild(sub);

    const controls = document.createElement("div");
    controls.className = "controls";

    const up = document.createElement("button");
    up.className = "small";
    up.textContent = "↑";
    up.disabled = idx === 0;
    up.addEventListener("click", () => {
      const t = timeline[idx-1];
      timeline[idx-1] = timeline[idx];
      timeline[idx] = t;
      timelineRender();
    });

    const down = document.createElement("button");
    down.className = "small";
    down.textContent = "↓";
    down.disabled = idx === timeline.length - 1;
    down.addEventListener("click", () => {
      const t = timeline[idx+1];
      timeline[idx+1] = timeline[idx];
      timeline[idx] = t;
      timelineRender();
    });

    const load = document.createElement("button");
    load.className = "small";
    load.textContent = "Load";
    load.addEventListener("click", () => {
      // Load this keyframe into the sliders (static state)
      setStaticState(item.state);
      toast(`Loaded keyframe: ${item.name}`);
      renderStatic();
    });

    const remove = document.createElement("button");
    remove.className = "small danger";
    remove.textContent = "✕";
    remove.addEventListener("click", () => {
      timeline.splice(idx, 1);
      timelineRender();
    });

    controls.appendChild(up);
    controls.appendChild(down);
    controls.appendChild(load);
    controls.appendChild(remove);

    div.appendChild(left);
    div.appendChild(controls);
    el.timelineList.appendChild(div);
  });
}

function timelineAddByName(profileName) {
  const profiles = loadProfiles();
  const state = profiles[profileName];
  if (!state) { toast("Profile not found."); return; }
  timeline.push({ name: profileName, state });
  timelineRender();
}

el.timelineAdd.addEventListener("click", () => {
  const name = el.timelineAddSelect.value;
  if (!name) { toast("Select a profile to add."); return; }
  timelineAddByName(name);
  toast(`Added to timeline: ${name}`);
});

el.timelineClear.addEventListener("click", () => {
  timeline = [];
  timelineRender();
  toast("Timeline cleared.");
});

el.timelineLoadDemo.addEventListener("click", () => {
  timeline = [];
  const demo = [
    "Calm Axis (Starter)",
    "Quietly Bent (Starter)",
    "Night Drift (Starter)",
    "Storm of Updates (Starter)",
    "Tender Permeability (Starter)",
  ];
  const profiles = loadProfiles();
  for (const name of demo) {
    if (profiles[name]) timeline.push({ name, state: profiles[name] });
  }
  timelineRender();
  el.animSeed.value = "demo-unified-seed-001";
  el.durationSec.value = 22;
  el.loopMode.value = "cycle";
  el.easing.value = "smootherstep";
  toast("Loaded demo timeline.");
});

/* ---------------------------
 * Aspect -> derived parameter model (same as before)
 * ---------------------------
 */
function deriveParams(a, rng) {
  const symmetry = clamp01(lerp(0.25, 0.95, a.coherence) * (1 - 0.25*a.tension));
  const fracture = clamp01(lerp(0.05, 0.85, a.tension) * (1 - 0.18*a.coherence));
  const density = clamp01(lerp(0.15, 0.95, a.recursion) + 0.08*a.vulnerability);
  const flow = clamp01(lerp(0.00, 0.95, a.motion) * (1 - 0.12*a.coherence) + 0.03*a.tension);
  const lum = clamp01(lerp(0.15, 0.95, a.radiance));
  const bleed = clamp01(lerp(0.00, 1.00, a.vulnerability) * (1 - 0.35*a.tension));
  const edgeSharpness = clamp01(lerp(0.15, 0.95, a.tension) * (1 - 0.45*a.vulnerability));
  const multiAxis = clamp01((1 - a.coherence) * a.tension);

  const paletteWobble = (rng()*2 - 1) * 14;
  const baseHue =
    (a.radiance > 0.62)
      ? lerp(215, 315, rng())
      : lerp(190, 285, rng());
  const hue = (baseHue + lerp(-35, 45, a.tension) + paletteWobble + 360) % 360;

  const nodeCount = Math.floor(lerp(3, 11, density));
  const shardLayers = 2 + Math.floor(lerp(1, 6, density));
  const shardsPerLayer = 10 + Math.floor(lerp(8, 36, density));

  const grain = lerp(0.02, 0.08, 1 - lum) + 0.02*fracture;
  const shardAlphaBase = lerp(0.04, 0.12, lum) * lerp(0.9, 1.25, 1 - edgeSharpness);
  const shardAlpha = clamp01(shardAlphaBase + 0.05*bleed);

  return { symmetry, fracture, density, flow, lum, bleed, edgeSharpness, multiAxis, hue, nodeCount, shardLayers, shardsPerLayer, grain, shardAlpha };
}

/* ---------------------------
 * Rendering helpers
 * ---------------------------
 */
function hsl(h, s, l, a=1) { return `hsla(${h}, ${s}%, ${l}%, ${a})`; }
function clear(bg) {
  ctx.save();
  ctx.globalCompositeOperation = "source-over";
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.restore();
}
function vignette(alpha=0.55) {
  const w = canvas.width, h = canvas.height;
  const g = ctx.createRadialGradient(w*0.5, h*0.52, Math.min(w,h)*0.12, w*0.5, h*0.52, Math.min(w,h)*0.62);
  g.addColorStop(0, `rgba(0,0,0,0)`);
  g.addColorStop(1, `rgba(0,0,0,${alpha})`);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}
function softGlow(x, y, r, a) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, r);
  g.addColorStop(0, `rgba(255,255,255,${a})`);
  g.addColorStop(1, `rgba(255,255,255,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.fill();
}
function addGrain(rng, amount=0.05) {
  const W = canvas.width, H = canvas.height;
  const img = ctx.getImageData(0,0,W,H);
  const d = img.data;
  const a = amount * 255;
  for (let i=0; i<d.length; i+=4) {
    const n = (rng()*2-1) * a;
    d[i]   = Math.max(0, Math.min(255, d[i] + n));
    d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
    d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
  }
  ctx.putImageData(img,0,0);
}
function signedNoise2D(x, y) {
  return (
    Math.sin(x*0.012 + 10.0) +
    Math.sin(y*0.015 - 4.0) +
    Math.sin((x+y)*0.008 + 2.7)
  ) / 3.0;
}

/* ---------------------------
 * Title + Alt-text (deterministic)
 * ---------------------------
 */
function generateTitle(a, rng) {
  const coh = a.coherence, ten = a.tension, rec = a.recursion, mot = a.motion, vul = a.vulnerability, rad = a.radiance;

  const coherenceWord = coh > 0.82 ? "Axis of Certainty" : coh > 0.60 ? "Measured Reflection" : "Unstable Mirror";
  const tensionWord = ten > 0.70 ? "Fractured" : ten > 0.40 ? "Under Tension" : "Quietly Bent";
  const recursionWord = rec > 0.72 ? "Recursive Field" : rec > 0.42 ? "Layered Model" : "Sparse Geometry";
  const motionWord = mot > 0.70 ? "Predictive Drift" : mot > 0.40 ? "Directional Echo" : "Latent Motion";
  const boundaryWord = vul > 0.70 ? "Permeable" : vul > 0.40 ? "Soft-Boundary" : "Hard-Edged";
  const radianceWord = rad > 0.75 ? "Luminous" : rad > 0.50 ? "Soft Radiance" : "Dark Coherence";

  const templates = [
    `${tensionWord} ${recursionWord}`,
    `${radianceWord}: ${coherenceWord}`,
    `${motionWord} Across ${coherenceWord}`,
    `${boundaryWord} ${recursionWord}`,
    `${coherenceWord}, ${tensionWord}`,
    `${radianceWord} ${recursionWord}`,
    `${motionWord} in ${radianceWord}`,
    `${boundaryWord} ${tensionWord} ${recursionWord}`,
  ];

  return templates[Math.floor(rng() * templates.length)];
}

function generateAltText(a, nodeCount, title) {
  const coherencePhrase = a.coherence > 0.82 ? "strong, almost ritual symmetry" : a.coherence > 0.62 ? "clear symmetry with deliberate slippage" : "loose symmetry, more suggestion than rule";
  const tensionPhrase = a.tension > 0.66 ? "visible fracture and purposeful misalignment" : a.tension > 0.34 ? "subtle tension at the edges of coherence" : "a mostly stable structure with faint stress lines";
  const recursionPhrase = a.recursion > 0.72 ? "densely layered, recursive geometry" : a.recursion > 0.46 ? "layered translucent polygons" : "a sparse set of geometric shards";
  const motionPhrase = a.motion > 0.70 ? "a prominent flow-field of vectors that bends and re-bends" : a.motion > 0.40 ? "a soft vector field suggesting prediction and revision" : "only a faint hint of directional flow";
  const boundaryPhrase = a.vulnerability > 0.70 ? "boundaries that bleed softly through each other" : a.vulnerability > 0.40 ? "semi-permeable edges where overlaps accumulate" : "edges that hold their separation";
  const tonePhrase = a.radiance > 0.75 ? "bright, glassy radiance" : a.radiance > 0.50 ? "soft, steady glow" : "low-light coherence";

  return [
    `Title: ${title}`,
    ``,
    `Alt-text (interpretive):`,
    `A near-black luminous field carries ${recursionPhrase}, arranged with ${coherencePhrase}.`,
    `The forms overlap without fully merging—${boundaryPhrase}—while ${tensionPhrase} keeps the structure honest.`,
    `Across the surface, ${motionPhrase} like thought made visible: short paths that imply direction, then curve under revision.`,
    `${nodeCount} attractor nodes punctuate the composition, suggesting stable commitments that still radiate change.`,
    `Overall mood: ${tonePhrase}; coherence under revision; connection and separateness held in the same geometry.`
  ].join("\n");
}

/* ---------------------------
 * Render core (parameterized by seed + aspects)
 * ---------------------------
 */
function renderWith(seedStr, aspects) {
  const seedFn = xmur3(seedStr);
  const rng = mulberry32(seedFn());

  const p = deriveParams(aspects, rng);

  el.derivedParams.textContent = [
    `seed=${seedStr}`,
    `sym=${p.symmetry.toFixed(3)}`,
    `fract=${p.fracture.toFixed(3)}`,
    `dens=${p.density.toFixed(3)}`,
    `flow=${p.flow.toFixed(3)}`,
    `lum=${p.lum.toFixed(3)}`,
    `bleed=${p.bleed.toFixed(3)}`,
    `edge=${p.edgeSharpness.toFixed(3)}`,
    `multiAxis=${p.multiAxis.toFixed(3)}`,
    `hue=${p.hue.toFixed(1)}`,
    `nodes=${p.nodeCount}`,
    `layers=${p.shardLayers}`,
    `shards/l=${p.shardsPerLayer}`,
  ].join(" · ");

  const title = generateTitle(aspects, rng);
  el.titleText.textContent = title;

  const W = canvas.width, H = canvas.height;
  const cx = W * 0.5, cy = H * 0.52;

  const bg = hsl(p.hue, 35, lerp(5, 12, p.lum), 1);
  clear(bg);

  // Field glow
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  const glowCount = 5 + Math.floor(lerp(1, 8, aspects.radiance));
  for (let i=0; i<glowCount; i++) {
    const x = lerp(W*0.20, W*0.80, rng());
    const y = lerp(H*0.22, H*0.78, rng());
    const r = lerp(220, 560, rng()) * lerp(0.7, 1.1, aspects.radiance);
    const alpha = lerp(0.02, 0.10, aspects.radiance) * (0.65 + 0.7*rng());
    softGlow(x, y, r, alpha);
  }
  ctx.restore();

  // Nodes
  const nodes = [];
  for (let i=0; i<p.nodeCount; i++) {
    const r = lerp(10, 28, rng());
    const x = lerp(W*0.20, W*0.80, rng());
    const y = lerp(H*0.22, H*0.82, rng());
    nodes.push({x, y, r});
  }

  // Symmetry axis hint
  const axisAlpha = lerp(0.00, 0.08, p.symmetry) * (1 - 0.35*p.fracture);
  if (axisAlpha > 0.001) {
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.strokeStyle = `rgba(255,255,255,${axisAlpha})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, H*0.10);
    ctx.lineTo(cx, H*0.92);
    ctx.stroke();
    ctx.restore();
  }

  function mirrorX(x) {
    const dx = x - cx;
    const perfect = cx - dx;
    const fractured = perfect + (rng()*2-1) * (p.fracture * 95);
    const axisSkew = (rng()*2-1) * (p.multiAxis * 60);
    return lerp(fractured + axisSkew, perfect, p.symmetry);
  }

  // Shards
  for (let layer=0; layer<p.shardLayers; layer++) {
    const hue = (p.hue + lerp(-35, 75, rng()) + layer*lerp(8, 18, rng())) % 360;
    const sat = lerp(35, 78, clamp01(p.lum + 0.15*rng()));
    const light = lerp(36, 72, clamp01(p.lum + 0.20*rng()));
    const layerT = 1 - layer / (p.shardLayers + 1);

    const alpha = p.shardAlpha * lerp(0.65, 1.25, layerT) * (1 + 0.35*p.bleed) * (1 - 0.18*p.edgeSharpness);

    ctx.save();
    ctx.globalCompositeOperation = (p.bleed > 0.55) ? "screen" : ((layer % 2 === 0) ? "lighter" : "screen");

    ctx.fillStyle = hsl(hue, sat, light, alpha);
    ctx.strokeStyle = hsl(hue, sat, light, alpha * 1.15);

    for (let s=0; s<p.shardsPerLayer; s++) {
      const sides = 3 + Math.floor(rng()*5);
      const radius = lerp(60, 235, rng()) * lerp(0.75, 1.10, layerT);
      const angle0 = rng() * Math.PI * 2;

      let x0 = lerp(W*0.18, W*0.82, rng());
      let y0 = lerp(H*0.18, H*0.86, rng());

      const n = nodes[Math.floor(rng()*nodes.length)];
      const attract = lerp(0.05, 0.24, p.density) * (0.7 + 0.7*rng());
      x0 = lerp(x0, n.x, attract);
      y0 = lerp(y0, n.y, attract);

      x0 += (rng()*2-1) * (p.bleed * 24);
      y0 += (rng()*2-1) * (p.bleed * 24);

      drawShard(ctx, x0, y0, radius, sides, angle0, rng, p);

      const xm = mirrorX(x0);
      const ym = y0 + (rng()*2-1) * p.fracture * 18;
      drawShard(ctx, xm, ym, radius * lerp(0.92, 1.06, rng()), sides, angle0 + (rng()*2-1)*p.fracture*0.25, rng, p);
    }

    ctx.restore();
  }

  function drawShard(ctx, x, y, radius, sides, angle0, rng, p) {
    const wobbleBase = lerp(0.22, 0.10, p.edgeSharpness) + p.fracture*0.12;
    const wobble = wobbleBase * (1 + 0.25*p.bleed);

    ctx.beginPath();
    for (let i=0; i<sides; i++) {
      const t = i / sides;
      const ang = angle0 + t*Math.PI*2;
      const w = 1 + (rng()*2-1) * wobble;
      const rr = radius * w * (0.92 + 0.16*Math.sin(ang*2 + rng()*2));
      const px = x + Math.cos(ang) * rr;
      const py = y + Math.sin(ang) * rr;
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = lerp(0.6, 1.6, 1 - p.edgeSharpness) * (0.7 + 0.6*rng());
    ctx.stroke();
  }

  // Flow field
  if (p.flow > 0.01) {
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.lineCap = "round";

    const grid = Math.floor(lerp(34, 92, clamp01(0.65*p.flow + 0.35*p.density)));
    const stepX = W / grid;
    const stepY = H / Math.floor(grid * (H/W));

    const hue = (p.hue + 120) % 360;
    ctx.strokeStyle = hsl(hue, lerp(28, 62, p.lum), lerp(52, 80, p.lum), lerp(0.06, 0.24, p.flow) * (1 + 0.25*p.bleed));

    for (let gy=0; gy<=H; gy+=stepY) {
      for (let gx=0; gx<=W; gx+=stepX) {
        const dx = gx - cx;
        const dy = gy - cy;

        let ang = Math.atan2(dy, dx) + Math.PI/2;
        const localNoise = signedNoise2D(gx, gy);
        const curvature = lerp(0.4, 2.2, p.flow) * (1 + 0.6*p.fracture) * (1 - 0.25*p.symmetry);
        ang += localNoise * curvature;

        // nearest node pull
        let nearest = nodes[0], bestD = Infinity;
        for (const n of nodes) {
          const dd = (gx-n.x)*(gx-n.x) + (gy-n.y)*(gy-n.y);
          if (dd < bestD) { bestD = dd; nearest = n; }
        }
        const toN = Math.atan2(nearest.y - gy, nearest.x - gx);
        ang = lerp(ang, toN, lerp(0.02, 0.14, p.density));

        // multi-axis drift
        if (p.multiAxis > 0.01) {
          const altCenterX = cx + (gx < cx ? -1 : 1) * (p.multiAxis * 170);
          const altDx = gx - altCenterX;
          const altAng = Math.atan2(dy, altDx) + Math.PI/2;
          ang = lerp(ang, altAng, p.multiAxis * 0.45);
        }

        const len = lerp(4, 18, p.flow) * (0.7 + 0.6*rng());
        const x2 = gx + Math.cos(ang) * len;
        const y2 = gy + Math.sin(ang) * len;

        ctx.lineWidth = lerp(0.6, 1.8, p.flow) * (0.6 + 0.7*rng()) * (1 - 0.15*p.edgeSharpness);
        ctx.beginPath();
        ctx.moveTo(gx, gy);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // Node glows
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  for (const n of nodes) {
    const glowR = n.r * lerp(6.5, 12.0, p.lum) * (1 + 0.35*p.bleed);
    softGlow(n.x, n.y, glowR, lerp(0.02, 0.09, aspects.radiance));
    softGlow(mirrorX(n.x), n.y, glowR * 0.92, lerp(0.015, 0.065, aspects.radiance));
  }
  ctx.restore();

  vignette(lerp(0.32, 0.70, 1 - p.lum));
  addGrain(rng, clamp01(p.grain));

  el.altText.textContent = generateAltText(aspects, nodes.length, title);

  return { title, params: p, nodeCount: nodes.length };
}

function renderStatic() {
  const state = getStaticState();
  updateAspectLabels(state.aspects);
  return renderWith(state.seed, state.aspects);
}

/* ---------------------------
 * Timeline interpolation + animation
 * ---------------------------
 */
function easingFn(kind, t) {
  t = clamp01(t);
  switch (kind) {
    case "linear": return t;
    case "cosine": return 0.5 - 0.5 * Math.cos(Math.PI * t);
    case "smootherstep": return t*t*t*(t*(t*6 - 15) + 10);
    case "smoothstep":
    default:
      return t*t*(3 - 2*t);
  }
}

function interpolateAspects(a, b, t) {
  return {
    coherence: lerp(a.coherence, b.coherence, t),
    tension: lerp(a.tension, b.tension, t),
    recursion: lerp(a.recursion, b.recursion, t),
    motion: lerp(a.motion, b.motion, t),
    vulnerability: lerp(a.vulnerability, b.vulnerability, t),
    radiance: lerp(a.radiance, b.radiance, t),
  };
}

function buildKeyframeSequence(loopMode) {
  // Returns array of states (timeline items) in playback order.
  if (timeline.length < 2) return [];
  if (loopMode === "pingpong") {
    const forward = timeline.slice();
    const back = timeline.slice(1, -1).reverse(); // avoid duplicating endpoints
    return forward.concat(back);
  }
  return timeline.slice(); // cycle
}

function getAnimatedAspectsAt(tNorm, seq, easingKind) {
  // tNorm in [0,1)
  const n = seq.length;
  if (n < 2) return null;

  const segT = tNorm * n; // 0..n
  const i = Math.floor(segT) % n;
  const j = (i + 1) % n;
  const local = segT - Math.floor(segT);
  const u = easingFn(easingKind, local);

  const a0 = seq[i].state.aspects;
  const a1 = seq[j].state.aspects;
  return interpolateAspects(a0, a1, u);
}

function tickAnimation(nowMs) {
  if (!anim.playing) return;

  const seq = buildKeyframeSequence(el.loopMode.value);
  if (seq.length < 2) {
    anim.playing = false;
    el.playPause.textContent = "Play";
    toast("Add 2+ profiles to animate.");
    return;
  }

  const durationMs = Math.max(2000, parseFloat(el.durationSec.value) * 1000);
  const t = (nowMs - anim.startMs) % durationMs;
  const tNorm = t / durationMs;

  el.progressBar.style.width = `${(tNorm * 100).toFixed(2)}%`;

  // Render with animated aspects using Animation Seed (constant for coherence)
  const aspects = getAnimatedAspectsAt(tNorm, seq, el.easing.value);
  anim.lastRenderedAspects = aspects;
  renderWith(el.animSeed.value.trim() || "anim-seed", aspects);

  requestAnimationFrame(tickAnimation);
}

el.playPause.addEventListener("click", () => {
  if (anim.playing) {
    anim.playing = false;
    el.playPause.textContent = "Play";
    toast("Paused.");
    return;
  }
  if (timeline.length < 2) {
    toast("Add 2+ profiles to the timeline first.");
    return;
  }
  anim.playing = true;
  anim.startMs = performance.now();
  el.playPause.textContent = "Pause";
  toast("Playing.");
  requestAnimationFrame(tickAnimation);
});

el.applyFromTimeline.addEventListener("click", () => {
  if (!anim.lastRenderedAspects) {
    toast("Play animation first, or render a frame.");
    return;
  }
  setAspectsToUI(anim.lastRenderedAspects);
  toast("Applied current animated frame to sliders.");
  renderStatic();
});

/* ---------------------------
 * Export helpers
 * ---------------------------
 */
function downloadBlob(filename, blob) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
function toIsoLocalish(d = new Date()) {
  const pad = (n) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function canvasToPngBlob(canvas) {
  return new Promise((resolve) => canvas.toBlob((b) => resolve(b), "image/png"));
}
function safeName(s) {
  return (s || "seed").replace(/[^a-z0-9_-]+/gi, "_").slice(0, 80);
}

/* ---------------------------
 * Static exports: PNG, ZIP
 * ---------------------------
 */
el.exportPng.addEventListener("click", () => {
  const a = document.createElement("a");
  a.download = `self-portrait_${safeName(el.seed.value)}.png`;
  a.href = canvas.toDataURL("image/png");
  a.click();
});

el.copyAlt.addEventListener("click", async () => {
  const text = el.altText.textContent || "";
  try {
    await navigator.clipboard.writeText(text);
    toast("Alt-text copied.");
  } catch {
    toast("Copy failed (clipboard blocked).");
  }
});

el.exportZip.addEventListener("click", async () => {
  if (!window.JSZip) {
    toast("JSZip failed to load (offline?). Vendor JSZip locally to fix.");
    return;
  }

  const state = getStaticState();
  const note = state.note;

  // Re-render once to ensure derived metadata aligns with output, but do not visually change canvas:
  // We use the same seed + aspects.
  const seedFn = xmur3(state.seed);
  const rng = mulberry32(seedFn());
  const title = generateTitle(state.aspects, rng);
  const derived = deriveParams(state.aspects, mulberry32(xmur3(state.seed)())); // separate rng instance ok for derived only
  const altText = el.altText.textContent || generateAltText(state.aspects, derived.nodeCount ?? 0, title);

  const timestamp = toIsoLocalish(new Date());
  const baseName = `self-portrait_${safeName(state.seed)}_${timestamp}`;
  const pngBlob = await canvasToPngBlob(canvas);

  const metadata = {
    kind: "static",
    title,
    seed: state.seed,
    note,
    aspects: state.aspects,
    canvas: { width: canvas.width, height: canvas.height },
    generated_at: new Date().toISOString(),
    files: ["image.png", "title.txt", "alt-text.txt", "note.txt", "metadata.json"]
  };

  const zip = new JSZip();
  zip.file(`${baseName}/image.png`, pngBlob);
  zip.file(`${baseName}/title.txt`, title + "\n");
  zip.file(`${baseName}/alt-text.txt`, (el.altText.textContent || "") + "\n");
  zip.file(`${baseName}/note.txt`, (note || "") + "\n");
  zip.file(`${baseName}/metadata.json`, JSON.stringify(metadata, null, 2) + "\n");

  const zipBlob = await zip.generateAsync({ type: "blob" });
  downloadBlob(`${baseName}.zip`, zipBlob);
  toast("Exported ZIP bundle.");
});

/* ---------------------------
 * WebM export (one or more full loops)
 * ---------------------------
 */
function pickMimeType() {
  const candidates = [
    "video/webm;codecs=vp9",
    "video/webm;codecs=vp8",
    "video/webm",
  ];
  for (const c of candidates) {
    if (typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported(c)) return c;
  }
  return "";
}

async function exportWebmLoop() {
  const seq = buildKeyframeSequence(el.loopMode.value);
  if (seq.length < 2) {
    toast("Add 2+ profiles to timeline.");
    return;
  }

  const fps = Math.max(12, Math.min(60, parseInt(el.fps.value, 10) || 30));
  const durationSec = Math.max(2, Math.min(300, parseFloat(el.durationSec.value) || 18));
  const loops = Math.max(1, Math.min(10, parseInt(el.exportLoops.value, 10) || 1));
  const totalDurationMs = durationSec * 1000 * loops;

  const seed = (el.animSeed.value.trim() || "anim-seed");
  const mimeType = pickMimeType();
  if (!mimeType) {
    toast("WebM recording not supported in this browser.");
    return;
  }

  // Capture stream from canvas
  const stream = canvas.captureStream(fps);
  const recorder = new MediaRecorder(stream, { mimeType });

  const chunks = [];
  recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };

  recorder.start(100); // request data every 100ms

  // Render loop at fps for exactly totalDurationMs
  const start = performance.now();
  const frameInterval = 1000 / fps;
  let nextFrame = start;

  toast(`Recording WebM (${loops} loop${loops>1?"s":""}, ${fps} fps)…`);

  while (performance.now() - start < totalDurationMs) {
    const now = performance.now();
    if (now >= nextFrame) {
      const elapsed = now - start;
      const tInLoop = elapsed % (durationSec * 1000);
      const tNorm = tInLoop / (durationSec * 1000);

      el.progressBar.style.width = `${(tNorm * 100).toFixed(2)}%`;

      const aspects = getAnimatedAspectsAt(tNorm, seq, el.easing.value);
      renderWith(seed, aspects);

      nextFrame += frameInterval;
    }
    // Yield to the browser
    await new Promise(r => setTimeout(r, 0));
  }

  recorder.stop();

  const blob = await new Promise((resolve) => {
    recorder.onstop = () => resolve(new Blob(chunks, { type: mimeType }));
  });

  const filename = `self-portrait_loop_${safeName(seed)}_${toIsoLocalish()}.webm`;
  downloadBlob(filename, blob);
  toast(`Saved: ${filename}`);
}

el.exportWebm.addEventListener("click", () => {
  exportWebmLoop().catch(() => toast("WebM export failed."));
});

/* ---------------------------
 * Static UI actions
 * ---------------------------
 */
function rerollSeed() {
  const base = (el.seed.value.trim() || "portrait").split("-")[0];
  const suffix = Math.random().toString(16).slice(2, 8);
  el.seed.value = `${base}-${suffix}`;
}

el.reroll.addEventListener("click", () => { rerollSeed(); renderStatic(); });
el.render.addEventListener("click", () => renderStatic());

for (const id of ["coherence", "tension", "recursion", "motion", "vulnerability", "radiance"]) {
  el[id].addEventListener("input", () => renderStatic());
}
el.seed.addEventListener("change", () => renderStatic());

/* ---------------------------
 * Init
 * ---------------------------
 */
renderPresetButtons();
ensureStarterProfiles();
refreshProfileSelects();
timelineRender();
renderStatic();
</script>
</body>
</html>
