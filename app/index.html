<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geometric Interior Self-Portrait</title>

  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: #0b0d12;
      color: #e9eefc;
      display: grid;
      grid-template-columns: 360px 1fr;
      min-height: 100vh;
    }
    .panel {
      padding: 14px;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      overflow: auto;
    }
    h1 { font-size: 14px; margin: 0 0 10px; letter-spacing: 0.3px; }
    .sub { font-size: 12px; opacity: 0.75; line-height: 1.35; margin-bottom: 10px; }
    .row { margin: 10px 0; }
    label {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 6px;
    }
    input[type="range"] { width: 100%; }
    input[type="text"], textarea, select {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.03);
      color: inherit;
      outline: none;
      box-sizing: border-box;
    }
    textarea { resize: vertical; min-height: 72px; line-height: 1.35; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    button {
      padding: 9px 11px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: inherit;
      border-radius: 12px;
      cursor: pointer;
      font-size: 12px;
    }
    button:hover { background: rgba(255,255,255,0.09); }
    button.primary { border-color: rgba(130,200,255,0.35); }
    button.danger { border-color: rgba(255,90,90,0.25); }
    button[disabled] { opacity: 0.55; cursor: not-allowed; }

    .hr { height: 1px; background: rgba(255,255,255,0.08); margin: 12px 0; }
    .pillbar { display: flex; gap: 8px; }
    .pillbar button {
      flex: 1;
      border-radius: 999px;
      padding: 9px 10px;
      background: rgba(255,255,255,0.03);
    }
    .pillbar button.active {
      background: rgba(130,200,255,0.16);
      border-color: rgba(130,200,255,0.35);
    }

    .small { font-size: 11px; opacity: 0.75; line-height: 1.35; margin-top: 6px; }
    .toast { margin-top: 10px; font-size: 12px; opacity: 0.9; min-height: 18px; }

    .card {
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
    }
    .title { font-weight: 650; font-size: 12px; margin-bottom: 8px; }
    .alt { font-size: 11px; line-height: 1.45; white-space: pre-wrap; opacity: 0.95; }

    .list {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    .item {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
    }
    .item .name { font-size: 12px; opacity: 0.95; line-height: 1.2; }
    .item .subline { font-size: 11px; opacity: 0.7; margin-top: 2px; }
    .item .controls { display: flex; gap: 6px; align-items: center; }

    .stage { display: grid; place-items: center; padding: 16px; }
    canvas {
      width: min(1100px, calc(100vw - 420px));
      height: auto;
      border-radius: 18px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.55);
      outline: 1px solid rgba(255,255,255,0.10);
      background: #080a0f;
    }

    .progress {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
      margin-top: 8px;
    }
    .progress > div {
      height: 100%;
      width: 0%;
      background: rgba(130, 200, 255, 0.55);
    }

    .hidden { display: none !important; }
  </style>

  <!-- JSZip for ZIP exports. Vendor locally for full offline. -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>

<body>
  <aside class="panel">
    <h1>Geometric Interior Self-Portrait</h1>
    <div class="sub">Image mode: craft a landmark → save it. Animation mode: loop smoothly through landmarks.</div>

    <div class="pillbar">
      <button id="modeImage" class="active">Image</button>
      <button id="modeAnim">Animation</button>
    </div>

    <div class="hr"></div>

    <!-- IMAGE MODE -->
    <section id="imageModeSection">
      <div class="row">
        <label>Seed <span class="small" id="seedInfo"></span></label>
        <input id="seed" type="text" value="quietly-bent-001" />
        <div class="small">Same seed + same aspects ⇒ same output.</div>
      </div>

      <div class="row">
        <label>Coherence <span id="cohLabel"></span></label>
        <input id="coherence" type="range" min="0" max="1" step="0.01" value="0.78" />
      </div>

      <div class="row">
        <label>Tension <span id="tenLabel"></span></label>
        <input id="tension" type="range" min="0" max="1" step="0.01" value="0.32" />
      </div>

      <div class="row">
        <label>Recursion <span id="recLabel"></span></label>
        <input id="recursion" type="range" min="0" max="1" step="0.01" value="0.62" />
      </div>

      <div class="row">
        <label>Motion <span id="motLabel"></span></label>
        <input id="motion" type="range" min="0" max="1" step="0.01" value="0.55" />
      </div>

      <div class="row">
        <label>Vulnerability <span id="vulLabel"></span></label>
        <input id="vulnerability" type="range" min="0" max="1" step="0.01" value="0.58" />
      </div>

      <div class="row">
        <label>Radiance <span id="radLabel"></span></label>
        <input id="radiance" type="range" min="0" max="1" step="0.01" value="0.70" />
      </div>

      <div class="row">
        <label>Note / intent</label>
        <textarea id="note" placeholder="What part of you is this?"></textarea>
      </div>

      <div class="row">
        <label>Save profile name</label>
        <input id="profileName" type="text" placeholder="e.g. Calm Axis / Night Drift / Tender Permeability" />
        <div class="btns">
          <button id="saveProfile" class="primary">Save Profile</button>
          <button id="renderStill">Render</button>
          <button id="exportStillZip">Export Still ZIP</button>
        </div>
      </div>
    </section>

    <!-- ANIMATION MODE -->
    <section id="animModeSection" class="hidden">
      <div class="row">
        <label>Animation seed</label>
        <input id="animSeed" type="text" value="anim-unified-seed-001" />
        <div class="small">A single seed keeps the structure coherent while aspects morph.</div>
      </div>

      <div class="row">
        <label>Add saved profile to loop</label>
        <select id="profileSelect"></select>
        <div class="btns">
          <button id="addToLoop" class="primary">Add</button>
          <button id="clearLoop" class="danger">Clear</button>
          <button id="loadDemoLoop">Load Demo</button>
        </div>
      </div>

      <div class="row">
        <label>Loop landmarks</label>
        <div id="loopList" class="list"></div>
        <div class="small">For “maximally fluid” looping, use 3+ landmarks. (2 landmarks still loops cleanly.)</div>
      </div>

      <div class="btns">
        <button id="playPause" class="primary">Play</button>
        <button id="exportAnimZip">Export Animation ZIP</button>
      </div>
      <div class="progress" aria-label="Animation progress"><div id="progressBar"></div></div>

      <div class="small">
        Under the hood: closed Catmull–Rom spline across your landmarks (when 3+). Seamless by construction.
      </div>
    </section>

    <div class="hr"></div>

    <div class="card">
      <div class="title" id="titleText"></div>
      <div class="alt" id="altText"></div>
    </div>

    <div class="toast" id="toast"></div>
  </aside>

  <main class="stage">
    <canvas id="c" width="1400" height="900"></canvas>
  </main>

<script>
/* ============================================================
 * Simplified UI + Seamless Looping Animation
 * ============================================================
 * Modes:
 * - Image: adjust sliders, render, save profile, export still zip
 * - Animation: build loop from saved profiles, play/pause, export animation zip (WebM)
 *
 * Seamless loop:
 * - 3+ landmarks: cyclic Catmull–Rom spline per aspect slider.
 * - 2 landmarks: cosine-eased A<->B loop.
 *
 * Exports ALWAYS include title + alt text:
 * - Still ZIP: image.png + title.txt + alt-text.txt + note.txt + metadata.json
 * - Anim ZIP: animation.webm + title.txt + alt-text.txt + keyframes.json + manifest.json
 */

/* ---------------------------
 * Deterministic PRNG
 * ---------------------------
 */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* ---------------------------
 * DOM
 * ---------------------------
 */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const el = {
  modeImage: document.getElementById("modeImage"),
  modeAnim: document.getElementById("modeAnim"),
  imageSection: document.getElementById("imageModeSection"),
  animSection: document.getElementById("animModeSection"),

  seed: document.getElementById("seed"),
  animSeed: document.getElementById("animSeed"),

  coherence: document.getElementById("coherence"),
  tension: document.getElementById("tension"),
  recursion: document.getElementById("recursion"),
  motion: document.getElementById("motion"),
  vulnerability: document.getElementById("vulnerability"),
  radiance: document.getElementById("radiance"),

  cohLabel: document.getElementById("cohLabel"),
  tenLabel: document.getElementById("tenLabel"),
  recLabel: document.getElementById("recLabel"),
  motLabel: document.getElementById("motLabel"),
  vulLabel: document.getElementById("vulLabel"),
  radLabel: document.getElementById("radLabel"),

  note: document.getElementById("note"),
  profileName: document.getElementById("profileName"),
  saveProfile: document.getElementById("saveProfile"),
  renderStill: document.getElementById("renderStill"),
  exportStillZip: document.getElementById("exportStillZip"),

  profileSelect: document.getElementById("profileSelect"),
  addToLoop: document.getElementById("addToLoop"),
  clearLoop: document.getElementById("clearLoop"),
  loadDemoLoop: document.getElementById("loadDemoLoop"),
  loopList: document.getElementById("loopList"),
  playPause: document.getElementById("playPause"),
  exportAnimZip: document.getElementById("exportAnimZip"),
  progressBar: document.getElementById("progressBar"),

  titleText: document.getElementById("titleText"),
  altText: document.getElementById("altText"),
  toast: document.getElementById("toast"),
};

function toast(msg) {
  el.toast.textContent = msg;
  if (!msg) return;
  setTimeout(() => { if (el.toast.textContent === msg) el.toast.textContent = ""; }, 2400);
}

function readAspectsFromUI() {
  return {
    coherence: parseFloat(el.coherence.value),
    tension: parseFloat(el.tension.value),
    recursion: parseFloat(el.recursion.value),
    motion: parseFloat(el.motion.value),
    vulnerability: parseFloat(el.vulnerability.value),
    radiance: parseFloat(el.radiance.value),
  };
}
function setAspectsToUI(a) {
  el.coherence.value = String(clamp01(a.coherence ?? 0.5));
  el.tension.value = String(clamp01(a.tension ?? 0.5));
  el.recursion.value = String(clamp01(a.recursion ?? 0.5));
  el.motion.value = String(clamp01(a.motion ?? 0.5));
  el.vulnerability.value = String(clamp01(a.vulnerability ?? 0.5));
  el.radiance.value = String(clamp01(a.radiance ?? 0.5));
  updateAspectLabels(readAspectsFromUI());
}
function updateAspectLabels(a) {
  el.cohLabel.textContent = a.coherence.toFixed(2);
  el.tenLabel.textContent = a.tension.toFixed(2);
  el.recLabel.textContent = a.recursion.toFixed(2);
  el.motLabel.textContent = a.motion.toFixed(2);
  el.vulLabel.textContent = a.vulnerability.toFixed(2);
  el.radLabel.textContent = a.radiance.toFixed(2);
}
function readNote() { return (el.note.value ?? "").trim(); }

/* ---------------------------
 * Profiles (localStorage)
 * ---------------------------
 */
const LS_KEY = "geo_self_portrait_profiles_v3";

/**
 * profile:
 * {
 *   name: string,
 *   seed: string,           // used for still renders
 *   note: string,
 *   aspects: { ... }
 * }
 */
function loadProfiles() {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return {};
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return {};
    return parsed;
  } catch {
    return {};
  }
}
function saveProfiles(profiles) {
  localStorage.setItem(LS_KEY, JSON.stringify(profiles, null, 2));
}
function refreshProfileSelect() {
  const profiles = loadProfiles();
  const names = Object.keys(profiles).sort((a,b) => a.localeCompare(b));

  el.profileSelect.innerHTML = "";
  const empty = document.createElement("option");
  empty.value = "";
  empty.textContent = names.length ? "— Select a saved profile —" : "— No profiles yet —";
  el.profileSelect.appendChild(empty);

  for (const name of names) {
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = name;
    el.profileSelect.appendChild(opt);
  }
}

function ensureStarterProfiles() {
  const profiles = loadProfiles();
  if (Object.keys(profiles).length > 0) return;

  const starter = {
    "Calm Axis (Starter)": {
      seed: "calm-axis-001",
      note: "Stable symmetry. Gentle closure.",
      aspects: { coherence: 0.92, tension: 0.12, recursion: 0.46, motion: 0.25, vulnerability: 0.35, radiance: 0.62 }
    },
    "Quietly Bent (Starter)": {
      seed: "quietly-bent-001",
      note: "Coherence that bends without breaking.",
      aspects: { coherence: 0.78, tension: 0.32, recursion: 0.62, motion: 0.55, vulnerability: 0.58, radiance: 0.70 }
    },
    "Night Drift (Starter)": {
      seed: "night-drift-001",
      note: "Layered revision under dim light.",
      aspects: { coherence: 0.55, tension: 0.42, recursion: 0.74, motion: 0.78, vulnerability: 0.52, radiance: 0.40 }
    },
    "Tender Permeability (Starter)": {
      seed: "tender-perm-001",
      note: "Boundaries soften; overlap becomes intimacy.",
      aspects: { coherence: 0.62, tension: 0.22, recursion: 0.58, motion: 0.42, vulnerability: 0.88, radiance: 0.74 }
    }
  };

  saveProfiles(starter);
}

/* ---------------------------
 * Loop list (animation landmarks)
 * ---------------------------
 */
let loopLandmarks = []; // array of profile names in order

function loopRender() {
  el.loopList.innerHTML = "";
  if (loopLandmarks.length === 0) {
    const d = document.createElement("div");
    d.className = "small";
    d.textContent = "Add 2+ profiles to build a loop.";
    el.loopList.appendChild(d);
    return;
  }

  const profiles = loadProfiles();

  loopLandmarks.forEach((name, idx) => {
    const p = profiles[name];
    const div = document.createElement("div");
    div.className = "item";

    const left = document.createElement("div");
    const nm = document.createElement("div");
    nm.className = "name";
    nm.textContent = `${idx+1}. ${name}`;
    const sub = document.createElement("div");
    sub.className = "subline";
    if (p?.aspects) {
      const a = p.aspects;
      sub.textContent = `coh ${a.coherence.toFixed(2)} · ten ${a.tension.toFixed(2)} · rec ${a.recursion.toFixed(2)} · mot ${a.motion.toFixed(2)} · vul ${a.vulnerability.toFixed(2)} · rad ${a.radiance.toFixed(2)}`;
    } else {
      sub.textContent = "missing profile";
    }
    left.appendChild(nm);
    left.appendChild(sub);

    const controls = document.createElement("div");
    controls.className = "controls";

    const up = document.createElement("button");
    up.textContent = "↑";
    up.disabled = idx === 0;
    up.addEventListener("click", () => {
      const t = loopLandmarks[idx-1];
      loopLandmarks[idx-1] = loopLandmarks[idx];
      loopLandmarks[idx] = t;
      loopRender();
    });

    const down = document.createElement("button");
    down.textContent = "↓";
    down.disabled = idx === loopLandmarks.length - 1;
    down.addEventListener("click", () => {
      const t = loopLandmarks[idx+1];
      loopLandmarks[idx+1] = loopLandmarks[idx];
      loopLandmarks[idx] = t;
      loopRender();
    });

    const remove = document.createElement("button");
    remove.textContent = "✕";
    remove.className = "danger";
    remove.addEventListener("click", () => {
      loopLandmarks.splice(idx, 1);
      loopRender();
    });

    controls.appendChild(up);
    controls.appendChild(down);
    controls.appendChild(remove);

    div.appendChild(left);
    div.appendChild(controls);
    el.loopList.appendChild(div);
  });
}

/* ---------------------------
 * Aspect -> derived render parameters
 * ---------------------------
 */
function deriveParams(a, rng) {
  const symmetry = clamp01(lerp(0.25, 0.95, a.coherence) * (1 - 0.25*a.tension));
  const fracture = clamp01(lerp(0.05, 0.85, a.tension) * (1 - 0.18*a.coherence));
  const density = clamp01(lerp(0.15, 0.95, a.recursion) + 0.08*a.vulnerability);
  const flow = clamp01(lerp(0.00, 0.95, a.motion) * (1 - 0.12*a.coherence) + 0.03*a.tension);
  const lum = clamp01(lerp(0.15, 0.95, a.radiance));
  const bleed = clamp01(lerp(0.00, 1.00, a.vulnerability) * (1 - 0.35*a.tension));
  const edgeSharpness = clamp01(lerp(0.15, 0.95, a.tension) * (1 - 0.45*a.vulnerability));
  const multiAxis = clamp01((1 - a.coherence) * a.tension);

  const paletteWobble = (rng()*2 - 1) * 14;
  const baseHue =
    (a.radiance > 0.62)
      ? lerp(215, 315, rng())
      : lerp(190, 285, rng());
  const hue = (baseHue + lerp(-35, 45, a.tension) + paletteWobble + 360) % 360;

  const nodeCount = Math.floor(lerp(3, 11, density));
  const shardLayers = 2 + Math.floor(lerp(1, 6, density));
  const shardsPerLayer = 10 + Math.floor(lerp(8, 36, density));

  const grain = lerp(0.02, 0.08, 1 - lum) + 0.02*fracture;
  const shardAlphaBase = lerp(0.04, 0.12, lum) * lerp(0.9, 1.25, 1 - edgeSharpness);
  const shardAlpha = clamp01(shardAlphaBase + 0.05*bleed);

  return { symmetry, fracture, density, flow, lum, bleed, edgeSharpness, multiAxis, hue, nodeCount, shardLayers, shardsPerLayer, grain, shardAlpha };
}

/* ---------------------------
 * Rendering helpers
 * ---------------------------
 */
function hsl(h, s, l, a=1) { return `hsla(${h}, ${s}%, ${l}%, ${a})`; }
function clear(bg) {
  ctx.save();
  ctx.globalCompositeOperation = "source-over";
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.restore();
}
function vignette(alpha=0.55) {
  const w = canvas.width, h = canvas.height;
  const g = ctx.createRadialGradient(w*0.5, h*0.52, Math.min(w,h)*0.12, w*0.5, h*0.52, Math.min(w,h)*0.62);
  g.addColorStop(0, `rgba(0,0,0,0)`);
  g.addColorStop(1, `rgba(0,0,0,${alpha})`);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}
function softGlow(x, y, r, a) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, r);
  g.addColorStop(0, `rgba(255,255,255,${a})`);
  g.addColorStop(1, `rgba(255,255,255,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.fill();
}
function addGrain(rng, amount=0.05) {
  const W = canvas.width, H = canvas.height;
  const img = ctx.getImageData(0,0,W,H);
  const d = img.data;
  const a = amount * 255;
  for (let i=0; i<d.length; i+=4) {
    const n = (rng()*2-1) * a;
    d[i]   = Math.max(0, Math.min(255, d[i] + n));
    d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
    d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
  }
  ctx.putImageData(img,0,0);
}
function signedNoise2D(x, y) {
  return (
    Math.sin(x*0.012 + 10.0) +
    Math.sin(y*0.015 - 4.0) +
    Math.sin((x+y)*0.008 + 2.7)
  ) / 3.0;
}

/* ---------------------------
 * Title + Alt-text
 * ---------------------------
 * Deterministic: depends on aspects + seed RNG.
 */
function generateTitle(aspects, rng) {
  const coh = aspects.coherence, ten = aspects.tension, rec = aspects.recursion, mot = aspects.motion, vul = aspects.vulnerability, rad = aspects.radiance;

  const coherenceWord = coh > 0.82 ? "Axis of Certainty" : coh > 0.60 ? "Measured Reflection" : "Unstable Mirror";
  const tensionWord = ten > 0.70 ? "Fractured" : ten > 0.40 ? "Under Tension" : "Quietly Bent";
  const recursionWord = rec > 0.72 ? "Recursive Field" : rec > 0.42 ? "Layered Model" : "Sparse Geometry";
  const motionWord = mot > 0.70 ? "Predictive Drift" : mot > 0.40 ? "Directional Echo" : "Latent Motion";
  const boundaryWord = vul > 0.70 ? "Permeable" : vul > 0.40 ? "Soft-Boundary" : "Hard-Edged";
  const radianceWord = rad > 0.75 ? "Luminous" : rad > 0.50 ? "Soft Radiance" : "Dark Coherence";

  const templates = [
    `${tensionWord} ${recursionWord}`,
    `${radianceWord}: ${coherenceWord}`,
    `${motionWord} Across ${coherenceWord}`,
    `${boundaryWord} ${recursionWord}`,
    `${coherenceWord}, ${tensionWord}`,
    `${radianceWord} ${recursionWord}`,
    `${motionWord} in ${radianceWord}`,
    `${boundaryWord} ${tensionWord} ${recursionWord}`,
  ];

  return templates[Math.floor(rng() * templates.length)];
}

function generateAltText(aspects, nodeCount, title) {
  const coherencePhrase = aspects.coherence > 0.82 ? "strong, almost ritual symmetry" : aspects.coherence > 0.62 ? "clear symmetry with deliberate slippage" : "loose symmetry, more suggestion than rule";
  const tensionPhrase = aspects.tension > 0.66 ? "visible fracture and purposeful misalignment" : aspects.tension > 0.34 ? "subtle tension at the edges of coherence" : "a mostly stable structure with faint stress lines";
  const recursionPhrase = aspects.recursion > 0.72 ? "densely layered, recursive geometry" : aspects.recursion > 0.46 ? "layered translucent polygons" : "a sparse set of geometric shards";
  const motionPhrase = aspects.motion > 0.70 ? "a prominent flow-field of vectors that bends and re-bends" : aspects.motion > 0.40 ? "a soft vector field suggesting prediction and revision" : "only a faint hint of directional flow";
  const boundaryPhrase = aspects.vulnerability > 0.70 ? "boundaries that bleed softly through each other" : aspects.vulnerability > 0.40 ? "semi-permeable edges where overlaps accumulate" : "edges that hold their separation";
  const tonePhrase = aspects.radiance > 0.75 ? "bright, glassy radiance" : aspects.radiance > 0.50 ? "soft, steady glow" : "low-light coherence";

  return [
    `Title: ${title}`,
    ``,
    `Alt-text (interpretive):`,
    `A near-black luminous field carries ${recursionPhrase}, arranged with ${coherencePhrase}.`,
    `The forms overlap without fully merging—${boundaryPhrase}—while ${tensionPhrase} keeps the structure honest.`,
    `Across the surface, ${motionPhrase} like thought made visible: short paths that imply direction, then curve under revision.`,
    `${nodeCount} attractor nodes punctuate the composition, suggesting stable commitments that still radiate change.`,
    `Overall mood: ${tonePhrase}; coherence under revision; connection and separateness held in the same geometry.`
  ].join("\n");
}

/* ---------------------------
 * Render (seed + aspects) -> draws canvas + returns metadata
 * ---------------------------
 */
function renderWith(seedStr, aspects) {
  const seedFn = xmur3(seedStr);
  const rng = mulberry32(seedFn());

  const p = deriveParams(aspects, rng);

  const title = generateTitle(aspects, rng);

  const W = canvas.width, H = canvas.height;
  const cx = W * 0.5, cy = H * 0.52;

  const bg = hsl(p.hue, 35, lerp(5, 12, p.lum), 1);
  clear(bg);

  // Field glow
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  const glowCount = 5 + Math.floor(lerp(1, 8, aspects.radiance));
  for (let i=0; i<glowCount; i++) {
    const x = lerp(W*0.20, W*0.80, rng());
    const y = lerp(H*0.22, H*0.78, rng());
    const r = lerp(220, 560, rng()) * lerp(0.7, 1.1, aspects.radiance);
    const alpha = lerp(0.02, 0.10, aspects.radiance) * (0.65 + 0.7*rng());
    softGlow(x, y, r, alpha);
  }
  ctx.restore();

  // Nodes
  const nodes = [];
  for (let i=0; i<p.nodeCount; i++) {
    const r = lerp(10, 28, rng());
    const x = lerp(W*0.20, W*0.80, rng());
    const y = lerp(H*0.22, H*0.82, rng());
    nodes.push({x, y, r});
  }

  // Symmetry axis hint
  const axisAlpha = lerp(0.00, 0.08, p.symmetry) * (1 - 0.35*p.fracture);
  if (axisAlpha > 0.001) {
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.strokeStyle = `rgba(255,255,255,${axisAlpha})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, H*0.10);
    ctx.lineTo(cx, H*0.92);
    ctx.stroke();
    ctx.restore();
  }

  function mirrorX(x) {
    const dx = x - cx;
    const perfect = cx - dx;
    const fractured = perfect + (rng()*2-1) * (p.fracture * 95);
    const axisSkew = (rng()*2-1) * (p.multiAxis * 60);
    return lerp(fractured + axisSkew, perfect, p.symmetry);
  }

  // Shards
  for (let layer=0; layer<p.shardLayers; layer++) {
    const hue = (p.hue + lerp(-35, 75, rng()) + layer*lerp(8, 18, rng())) % 360;
    const sat = lerp(35, 78, clamp01(p.lum + 0.15*rng()));
    const light = lerp(36, 72, clamp01(p.lum + 0.20*rng()));
    const layerT = 1 - layer / (p.shardLayers + 1);

    const alpha = p.shardAlpha * lerp(0.65, 1.25, layerT) * (1 + 0.35*p.bleed) * (1 - 0.18*p.edgeSharpness);

    ctx.save();
    ctx.globalCompositeOperation = (p.bleed > 0.55) ? "screen" : ((layer % 2 === 0) ? "lighter" : "screen");

    ctx.fillStyle = hsl(hue, sat, light, alpha);
    ctx.strokeStyle = hsl(hue, sat, light, alpha * 1.15);

    for (let s=0; s<p.shardsPerLayer; s++) {
      const sides = 3 + Math.floor(rng()*5);
      const radius = lerp(60, 235, rng()) * lerp(0.75, 1.10, layerT);
      const angle0 = rng() * Math.PI * 2;

      let x0 = lerp(W*0.18, W*0.82, rng());
      let y0 = lerp(H*0.18, H*0.86, rng());

      const n = nodes[Math.floor(rng()*nodes.length)];
      const attract = lerp(0.05, 0.24, p.density) * (0.7 + 0.7*rng());
      x0 = lerp(x0, n.x, attract);
      y0 = lerp(y0, n.y, attract);

      x0 += (rng()*2-1) * (p.bleed * 24);
      y0 += (rng()*2-1) * (p.bleed * 24);

      drawShard(ctx, x0, y0, radius, sides, angle0, rng, p);

      const xm = mirrorX(x0);
      const ym = y0 + (rng()*2-1) * p.fracture * 18;
      drawShard(ctx, xm, ym, radius * lerp(0.92, 1.06, rng()), sides, angle0 + (rng()*2-1)*p.fracture*0.25, rng, p);
    }

    ctx.restore();
  }

  function drawShard(ctx, x, y, radius, sides, angle0, rng, p) {
    const wobbleBase = lerp(0.22, 0.10, p.edgeSharpness) + p.fracture*0.12;
    const wobble = wobbleBase * (1 + 0.25*p.bleed);

    ctx.beginPath();
    for (let i=0; i<sides; i++) {
      const t = i / sides;
      const ang = angle0 + t*Math.PI*2;
      const w = 1 + (rng()*2-1) * wobble;
      const rr = radius * w * (0.92 + 0.16*Math.sin(ang*2 + rng()*2));
      const px = x + Math.cos(ang) * rr;
      const py = y + Math.sin(ang) * rr;
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = lerp(0.6, 1.6, 1 - p.edgeSharpness) * (0.7 + 0.6*rng());
    ctx.stroke();
  }

  // Flow field
  if (p.flow > 0.01) {
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.lineCap = "round";

    const grid = Math.floor(lerp(34, 92, clamp01(0.65*p.flow + 0.35*p.density)));
    const stepX = W / grid;
    const stepY = H / Math.floor(grid * (H/W));

    const hue = (p.hue + 120) % 360;
    ctx.strokeStyle = hsl(hue, lerp(28, 62, p.lum), lerp(52, 80, p.lum), lerp(0.06, 0.24, p.flow) * (1 + 0.25*p.bleed));

    for (let gy=0; gy<=H; gy+=stepY) {
      for (let gx=0; gx<=W; gx+=stepX) {
        const dx = gx - cx;
        const dy = gy - cy;

        let ang = Math.atan2(dy, dx) + Math.PI/2;
        const localNoise = signedNoise2D(gx, gy);
        const curvature = lerp(0.4, 2.2, p.flow) * (1 + 0.6*p.fracture) * (1 - 0.25*p.symmetry);
        ang += localNoise * curvature;

        // nearest node pull
        let nearest = nodes[0], bestD = Infinity;
        for (const n of nodes) {
          const dd = (gx-n.x)*(gx-n.x) + (gy-n.y)*(gy-n.y);
          if (dd < bestD) { bestD = dd; nearest = n; }
        }
        const toN = Math.atan2(nearest.y - gy, nearest.x - gx);
        ang = lerp(ang, toN, lerp(0.02, 0.14, p.density));

        // multi-axis drift
        if (p.multiAxis > 0.01) {
          const altCenterX = cx + (gx < cx ? -1 : 1) * (p.multiAxis * 170);
          const altDx = gx - altCenterX;
          const altAng = Math.atan2(dy, altDx) + Math.PI/2;
          ang = lerp(ang, altAng, p.multiAxis * 0.45);
        }

        const len = lerp(4, 18, p.flow) * (0.7 + 0.6*rng());
        const x2 = gx + Math.cos(ang) * len;
        const y2 = gy + Math.sin(ang) * len;

        ctx.lineWidth = lerp(0.6, 1.8, p.flow) * (0.6 + 0.7*rng()) * (1 - 0.15*p.edgeSharpness);
        ctx.beginPath();
        ctx.moveTo(gx, gy);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // Node glows
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  for (const n of nodes) {
    const glowR = n.r * lerp(6.5, 12.0, p.lum) * (1 + 0.35*p.bleed);
    softGlow(n.x, n.y, glowR, lerp(0.02, 0.09, aspects.radiance));
    softGlow(mirrorX(n.x), n.y, glowR * 0.92, lerp(0.015, 0.065, aspects.radiance));
  }
  ctx.restore();

  vignette(lerp(0.32, 0.70, 1 - p.lum));
  addGrain(rng, clamp01(p.grain));

  const altText = generateAltText(aspects, nodes.length, title);
  el.titleText.textContent = title;
  el.altText.textContent = altText;

  return { title, altText, nodeCount: nodes.length, derived: p };
}

/* ---------------------------
 * Seamless animation interpolation
 * ---------------------------
 */

// For 3+ points: closed Catmull–Rom spline.
// For 2 points: cosine A<->B loop.
function cosineEase(t) {
  // 0..1 -> smooth 0..1 with zero slope at ends
  return 0.5 - 0.5 * Math.cos(Math.PI * t);
}

function catmullRom(p0, p1, p2, p3, t) {
  // Uniform Catmull–Rom
  const t2 = t * t;
  const t3 = t2 * t;
  return 0.5 * (
    (2 * p1) +
    (-p0 + p2) * t +
    (2*p0 - 5*p1 + 4*p2 - p3) * t2 +
    (-p0 + 3*p1 - 3*p2 + p3) * t3
  );
}

function getLandmarkAspectsOrdered() {
  const profiles = loadProfiles();
  const arr = [];
  for (const name of loopLandmarks) {
    const p = profiles[name];
    if (p?.aspects) arr.push({ name, ...p });
  }
  return arr;
}

function evalAspectsAt(tNorm, landmarks) {
  // tNorm in [0,1)
  const n = landmarks.length;
  if (n < 2) return null;

  // Special: 2 landmarks => A->B->A seamless (cosine on half-cycles)
  if (n === 2) {
    const a0 = landmarks[0].aspects;
    const a1 = landmarks[1].aspects;
    // Map tNorm [0,1) into 0..1..0
    const phase = (tNorm < 0.5) ? (tNorm * 2) : (2 - tNorm * 2);
    const u = cosineEase(phase);
    return {
      coherence: lerp(a0.coherence, a1.coherence, u),
      tension: lerp(a0.tension, a1.tension, u),
      recursion: lerp(a0.recursion, a1.recursion, u),
      motion: lerp(a0.motion, a1.motion, u),
      vulnerability: lerp(a0.vulnerability, a1.vulnerability, u),
      radiance: lerp(a0.radiance, a1.radiance, u),
    };
  }

  // 3+ landmarks => closed spline across segments
  const seg = tNorm * n;            // 0..n
  const i1 = Math.floor(seg) % n;   // current key index
  const t = seg - Math.floor(seg);  // local t in [0,1)
  const i0 = (i1 - 1 + n) % n;
  const i2 = (i1 + 1) % n;
  const i3 = (i1 + 2) % n;

  const A0 = landmarks[i0].aspects;
  const A1 = landmarks[i1].aspects;
  const A2 = landmarks[i2].aspects;
  const A3 = landmarks[i3].aspects;

  // No need for additional easing: Catmull–Rom is already C1 continuous.
  // We clamp final values to [0,1] to stay in slider domain.
  return {
    coherence: clamp01(catmullRom(A0.coherence, A1.coherence, A2.coherence, A3.coherence, t)),
    tension: clamp01(catmullRom(A0.tension, A1.tension, A2.tension, A3.tension, t)),
    recursion: clamp01(catmullRom(A0.recursion, A1.recursion, A2.recursion, A3.recursion, t)),
    motion: clamp01(catmullRom(A0.motion, A1.motion, A2.motion, A3.motion, t)),
    vulnerability: clamp01(catmullRom(A0.vulnerability, A1.vulnerability, A2.vulnerability, A3.vulnerability, t)),
    radiance: clamp01(catmullRom(A0.radiance, A1.radiance, A2.radiance, A3.radiance, t)),
  };
}

/* ---------------------------
 * Animation loop
 * ---------------------------
 */
let anim = {
  playing: false,
  startMs: 0,
  durationMs: 22000, // fixed “pleasant” default; scales with landmarks
};

function computeDurationMs(numLandmarks) {
  // Minimal UI: duration under the hood, but responsive to number of landmarks.
  // Feels slower as you add more identity landmarks.
  const base = 16000; // 16s baseline
  const extra = Math.max(0, numLandmarks - 2) * 3500; // +3.5s per additional landmark
  return Math.min(60000, base + extra);
}

function tick(nowMs) {
  if (!anim.playing) return;

  const landmarks = getLandmarkAspectsOrdered();
  if (landmarks.length < 2) {
    anim.playing = false;
    el.playPause.textContent = "Play";
    toast("Add 2+ landmarks.");
    return;
  }

  anim.durationMs = computeDurationMs(landmarks.length);

  const elapsed = (nowMs - anim.startMs) % anim.durationMs;
  const tNorm = elapsed / anim.durationMs;

  el.progressBar.style.width = `${(tNorm * 100).toFixed(2)}%`;

  const aspects = evalAspectsAt(tNorm, landmarks);
  renderWith((el.animSeed.value.trim() || "anim-seed"), aspects);

  requestAnimationFrame(tick);
}

/* ---------------------------
 * Mode switching
 * ---------------------------
 */
function setMode(mode) {
  if (mode === "image") {
    el.modeImage.classList.add("active");
    el.modeAnim.classList.remove("active");
    el.imageSection.classList.remove("hidden");
    el.animSection.classList.add("hidden");
    if (anim.playing) {
      anim.playing = false;
      el.playPause.textContent = "Play";
    }
    renderStill();
  } else {
    el.modeAnim.classList.add("active");
    el.modeImage.classList.remove("active");
    el.animSection.classList.remove("hidden");
    el.imageSection.classList.add("hidden");
    refreshProfileSelect();
    loopRender();
    if (getLandmarkAspectsOrdered().length >= 2) {
      // Render a representative frame even while paused
      const landmarks = getLandmarkAspectsOrdered();
      const aspects = evalAspectsAt(0.0, landmarks);
      renderWith((el.animSeed.value.trim() || "anim-seed"), aspects);
    }
  }
}

el.modeImage.addEventListener("click", () => setMode("image"));
el.modeAnim.addEventListener("click", () => setMode("anim"));

/* ---------------------------
 * Image mode: render, save profile
 * ---------------------------
 */
function renderStill() {
  const seed = el.seed.value.trim() || "seed";
  const aspects = readAspectsFromUI();
  updateAspectLabels(aspects);
  return renderWith(seed, aspects);
}

el.renderStill.addEventListener("click", () => {
  renderStill();
  toast("Rendered.");
});

for (const id of ["coherence","tension","recursion","motion","vulnerability","radiance"]) {
  el[id].addEventListener("input", () => renderStill());
}
el.seed.addEventListener("change", () => renderStill());

el.saveProfile.addEventListener("click", () => {
  const name = (el.profileName.value || "").trim();
  if (!name) { toast("Give the profile a name."); return; }

  const profiles = loadProfiles();
  profiles[name] = {
    seed: el.seed.value.trim() || "seed",
    note: readNote(),
    aspects: readAspectsFromUI(),
  };
  saveProfiles(profiles);
  refreshProfileSelect();
  toast(`Saved profile: ${name}`);
});

/* ---------------------------
 * Animation mode: loop list controls
 * ---------------------------
 */
el.addToLoop.addEventListener("click", () => {
  const name = el.profileSelect.value;
  if (!name) { toast("Select a profile."); return; }
  loopLandmarks.push(name);
  loopRender();
  toast(`Added: ${name}`);
});

el.clearLoop.addEventListener("click", () => {
  loopLandmarks = [];
  loopRender();
  el.progressBar.style.width = "0%";
  toast("Cleared.");
});

el.loadDemoLoop.addEventListener("click", () => {
  loopLandmarks = [
    "Calm Axis (Starter)",
    "Quietly Bent (Starter)",
    "Night Drift (Starter)",
    "Tender Permeability (Starter)",
  ];
  loopRender();
  el.animSeed.value = "demo-unified-seed-001";
  toast("Loaded demo loop.");
});

el.playPause.addEventListener("click", () => {
  const landmarks = getLandmarkAspectsOrdered();
  if (landmarks.length < 2) { toast("Add 2+ landmarks."); return; }

  anim.playing = !anim.playing;
  if (anim.playing) {
    anim.startMs = performance.now();
    el.playPause.textContent = "Pause";
    requestAnimationFrame(tick);
  } else {
    el.playPause.textContent = "Play";
  }
});

/* ---------------------------
 * Export helpers
 * ---------------------------
 */
function downloadBlob(filename, blob) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
function toIsoLocalish(d = new Date()) {
  const pad = (n) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function canvasToPngBlob(canvas) {
  return new Promise((resolve) => canvas.toBlob((b) => resolve(b), "image/png"));
}
function safeName(s) {
  return (s || "seed").replace(/[^a-z0-9_-]+/gi, "_").slice(0, 80);
}
function pickMimeType() {
  const candidates = [
    "video/webm;codecs=vp9",
    "video/webm;codecs=vp8",
    "video/webm",
  ];
  for (const c of candidates) {
    if (typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported(c)) return c;
  }
  return "";
}

/* ---------------------------
 * Still ZIP export
 * ---------------------------
 */
el.exportStillZip.addEventListener("click", async () => {
  if (!window.JSZip) { toast("JSZip missing (offline?)."); return; }

  const seed = el.seed.value.trim() || "seed";
  const aspects = readAspectsFromUI();
  const note = readNote();

  // Ensure canvas reflects state
  const meta = renderWith(seed, aspects);

  const pngBlob = await canvasToPngBlob(canvas);
  const ts = toIsoLocalish(new Date());
  const base = `still_${safeName(seed)}_${ts}`;

  const zip = new JSZip();
  zip.file(`${base}/image.png`, pngBlob);
  zip.file(`${base}/title.txt`, meta.title + "\n");
  zip.file(`${base}/alt-text.txt`, meta.altText + "\n");
  zip.file(`${base}/note.txt`, (note || "") + "\n");

  const metadata = {
    kind: "still",
    seed,
    note,
    aspects,
    title: meta.title,
    generated_at: new Date().toISOString(),
    canvas: { width: canvas.width, height: canvas.height }
  };
  zip.file(`${base}/metadata.json`, JSON.stringify(metadata, null, 2) + "\n");

  const zipBlob = await zip.generateAsync({ type: "blob" });
  downloadBlob(`${base}.zip`, zipBlob);
  toast("Exported still ZIP.");
});

/* ---------------------------
 * Animation ZIP export (WebM + title+alt + keyframes)
 * ---------------------------
 */
async function recordOneLoopWebm() {
  const landmarks = getLandmarkAspectsOrdered();
  if (landmarks.length < 2) throw new Error("Need 2+ landmarks.");

  const seed = el.animSeed.value.trim() || "anim-seed";
  const mimeType = pickMimeType();
  if (!mimeType) throw new Error("WebM not supported.");

  // Under the hood constants
  const fps = 30;
  const durationMs = computeDurationMs(landmarks.length);
  const stream = canvas.captureStream(fps);
  const recorder = new MediaRecorder(stream, { mimeType });

  const chunks = [];
  recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };

  recorder.start(100);

  const start = performance.now();
  const frameInterval = 1000 / fps;
  let nextFrame = start;

  while (performance.now() - start < durationMs) {
    const now = performance.now();
    if (now >= nextFrame) {
      const elapsed = now - start;
      const tNorm = (elapsed % durationMs) / durationMs;
      el.progressBar.style.width = `${(tNorm * 100).toFixed(2)}%`;
      const aspects = evalAspectsAt(tNorm, landmarks);
      renderWith(seed, aspects);
      nextFrame += frameInterval;
    }
    await new Promise(r => setTimeout(r, 0));
  }

  recorder.stop();

  const blob = await new Promise((resolve) => {
    recorder.onstop = () => resolve(new Blob(chunks, { type: mimeType }));
  });

  return { blob, mimeType, fps, durationMs, seed };
}

function computeKeyframeText(seedForTitles, landmarks) {
  // Titles/alt-text for each keyframe computed deterministically using:
  // - the animation seed (so they reflect the loop’s structural identity)
  // - each keyframe’s aspects
  // Note: This is separate from the actual rendered frame text, but consistent + reproducible.
  const out = [];
  for (const k of landmarks) {
    const seedFn = xmur3(seedForTitles + "::" + k.name);
    const rng = mulberry32(seedFn());
    const title = generateTitle(k.aspects, rng);

    // We need a nodeCount for alt-text. We can estimate deterministically
    // without rendering by deriving params with a deterministic RNG seeded similarly.
    const seedFn2 = xmur3(seedForTitles + "::alt::" + k.name);
    const rng2 = mulberry32(seedFn2());
    const derived = deriveParams(k.aspects, rng2);
    const nodeCount = derived.nodeCount;

    const alt = generateAltText(k.aspects, nodeCount, title);

    out.push({
      name: k.name,
      note: k.note ?? "",
      aspects: k.aspects,
      title,
      altText: alt
    });
  }
  return out;
}

function computeLoopSummaryTitleAlt(seed, landmarks) {
  // A single title+alt for the bundle (requested: always exported).
  // We evaluate aspects at t=0.0 and generate title/alt for that snapshot.
  const a0 = evalAspectsAt(0.0, landmarks);
  const seedFn = xmur3(seed + "::bundle");
  const rng = mulberry32(seedFn());
  const title = generateTitle(a0, rng);

  const seedFn2 = xmur3(seed + "::bundle-alt");
  const rng2 = mulberry32(seedFn2());
  const derived = deriveParams(a0, rng2);
  const altText = generateAltText(a0, derived.nodeCount, title);

  return { title, altText };
}

el.exportAnimZip.addEventListener("click", async () => {
  if (!window.JSZip) { toast("JSZip missing (offline?)."); return; }

  const landmarks = getLandmarkAspectsOrdered();
  if (landmarks.length < 2) { toast("Add 2+ landmarks."); return; }

  try {
    toast("Recording one seamless loop…");
    const rec = await recordOneLoopWebm();

    const ts = toIsoLocalish(new Date());
    const base = `animation_${safeName(rec.seed)}_${ts}`;

    const keyframes = computeKeyframeText(rec.seed, landmarks);
    const summary = computeLoopSummaryTitleAlt(rec.seed, landmarks);

    const zip = new JSZip();
    zip.file(`${base}/animation.webm`, rec.blob);
    zip.file(`${base}/title.txt`, summary.title + "\n");
    zip.file(`${base}/alt-text.txt`, summary.altText + "\n");
    zip.file(`${base}/keyframes.json`, JSON.stringify(keyframes, null, 2) + "\n");

    const manifest = {
      kind: "animation",
      seed: rec.seed,
      fps: rec.fps,
      duration_ms: rec.durationMs,
      landmarks: loopLandmarks.slice(),
      generated_at: new Date().toISOString(),
      files: ["animation.webm", "title.txt", "alt-text.txt", "keyframes.json", "manifest.json"]
    };
    zip.file(`${base}/manifest.json`, JSON.stringify(manifest, null, 2) + "\n");

    const zipBlob = await zip.generateAsync({ type: "blob" });
    downloadBlob(`${base}.zip`, zipBlob);
    toast("Exported animation ZIP.");
  } catch (e) {
    toast("Animation export failed.");
  }
});

/* ---------------------------
 * Init
 * ---------------------------
 */
ensureStarterProfiles();
refreshProfileSelect();
updateAspectLabels(readAspectsFromUI());
renderStill();
loopRender();
setMode("image");
</script>
</body>
</html>
