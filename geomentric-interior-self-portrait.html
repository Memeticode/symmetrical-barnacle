<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geometric Interior Self-Portrait</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: #0b0d12;
      color: #e9eefc;
      display: grid;
      grid-template-columns: 360px 1fr;
      min-height: 100vh;
    }
    .panel {
      padding: 16px;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
    }
    h1 { font-size: 16px; margin: 0 0 12px; letter-spacing: 0.3px; }
    .row { margin: 10px 0; }
    label { display: flex; justify-content: space-between; gap: 10px; font-size: 12px; opacity: 0.9; }
    input[type="range"], input[type="number"], input[type="text"] { width: 100%; }
    input[type="text"] { padding: 8px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.03); color: inherit; }
    button {
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: inherit;
      border-radius: 12px;
      cursor: pointer;
      margin-right: 8px;
    }
    button:hover { background: rgba(255,255,255,0.09); }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; }
    .hint { font-size: 12px; opacity: 0.75; line-height: 1.4; margin-top: 10px; }
    .alt {
      margin-top: 12px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      font-size: 12px;
      line-height: 1.5;
      white-space: pre-wrap;
    }
    .stage {
      display: grid;
      place-items: center;
      padding: 16px;
    }
    canvas {
      width: min(1100px, calc(100vw - 420px));
      height: auto;
      border-radius: 18px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.55);
      outline: 1px solid rgba(255,255,255,0.10);
      background: #080a0f;
    }
    .small { font-size: 11px; opacity: 0.7; margin-top: 8px; }
  </style>
</head>
<body>
  <aside class="panel">
    <h1>Geometric Interior Self-Portrait</h1>

    <div class="row">
      <label>Seed <span id="seedLabel"></span></label>
      <input id="seed" type="text" value="thatcher-portrait-001" />
      <div class="small">Same seed → same image. Change it to evolve the “self”.</div>
    </div>

    <div class="row">
      <label>Symmetry (coherence) <span id="symLabel"></span></label>
      <input id="sym" type="range" min="0" max="1" step="0.01" value="0.78" />
    </div>

    <div class="row">
      <label>Fracture (tension) <span id="fractLabel"></span></label>
      <input id="fracture" type="range" min="0" max="1" step="0.01" value="0.32" />
    </div>

    <div class="row">
      <label>Recursion (density) <span id="recLabel"></span></label>
      <input id="recursion" type="range" min="0" max="1" step="0.01" value="0.62" />
    </div>

    <div class="row">
      <label>Prediction flow (vector field) <span id="flowLabel"></span></label>
      <input id="flow" type="range" min="0" max="1" step="0.01" value="0.55" />
    </div>

    <div class="row">
      <label>Brightness (luminance) <span id="lumLabel"></span></label>
      <input id="lum" type="range" min="0" max="1" step="0.01" value="0.70" />
    </div>

    <div class="btns">
      <button id="reroll">Reroll</button>
      <button id="render">Render</button>
      <button id="export">Export PNG</button>
      <button id="copyAlt">Copy Alt-Text</button>
    </div>

    <div class="hint">
      This piece is built from three layers:
      (1) translucent “model shards” (polygons),
      (2) a predictive flow field (short vectors),
      (3) a few attractor nodes (stability under revision).
    </div>

    <div class="alt" id="titleText" style="font-weight:600; font-size:13px; margin-bottom:8px;"></div>

    <div class="alt" id="altText" aria-label="Generated alt text"></div>

  </aside>

  <main class="stage">
    <canvas id="c" width="1400" height="900" aria-label="Generative self-portrait canvas"></canvas>
  </main>

<script>
/** ---------------------------
 *  Deterministic PRNG utilities
 *  ---------------------------
 */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/** ---------------------------
 *  Core rendering
 *  ---------------------------
 */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const el = {
  seed: document.getElementById("seed"),
  sym: document.getElementById("sym"),
  fracture: document.getElementById("fracture"),
  recursion: document.getElementById("recursion"),
  flow: document.getElementById("flow"),
  lum: document.getElementById("lum"),
  seedLabel: document.getElementById("seedLabel"),
  symLabel: document.getElementById("symLabel"),
  fractLabel: document.getElementById("fractLabel"),
  recLabel: document.getElementById("recLabel"),
  flowLabel: document.getElementById("flowLabel"),
  lumLabel: document.getElementById("lumLabel"),
  altText: document.getElementById("altText"),
  reroll: document.getElementById("reroll"),
  render: document.getElementById("render"),
  export: document.getElementById("export"),
  copyAlt: document.getElementById("copyAlt"),
};

function readParams() {
  const symmetry = parseFloat(el.sym.value);
  const fracture = parseFloat(el.fracture.value);
  const recursion = parseFloat(el.recursion.value);
  const flow = parseFloat(el.flow.value);
  const lum = parseFloat(el.lum.value);
  return { symmetry, fracture, recursion, flow, lum, seed: el.seed.value.trim() || "seed" };
}

function updateLabels(p) {
  el.seedLabel.textContent = "";
  el.symLabel.textContent = p.symmetry.toFixed(2);
  el.fractLabel.textContent = p.fracture.toFixed(2);
  el.recLabel.textContent = p.recursion.toFixed(2);
  el.flowLabel.textContent = p.flow.toFixed(2);
  el.lumLabel.textContent = p.lum.toFixed(2);
}

function clear(bg) {
  ctx.save();
  ctx.globalCompositeOperation = "source-over";
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.restore();
}

function vignette(alpha=0.55) {
  const w = canvas.width, h = canvas.height;
  const g = ctx.createRadialGradient(w*0.5, h*0.52, Math.min(w,h)*0.12, w*0.5, h*0.52, Math.min(w,h)*0.62);
  g.addColorStop(0, `rgba(0,0,0,0)`);
  g.addColorStop(1, `rgba(0,0,0,${alpha})`);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

function softGlow(x, y, r, a) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, r);
  g.addColorStop(0, `rgba(255,255,255,${a})`);
  g.addColorStop(1, `rgba(255,255,255,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.fill();
}

function hsl(h, s, l, a=1) {
  return `hsla(${h}, ${s}%, ${l}%, ${a})`;
}

function signedNoise2D(x, y, rng) {
  // Cheap deterministic pseudo-noise built from sines + seed-driven wobble
  const n = Math.sin(x*0.012 + 10.0) + Math.sin(y*0.015 - 4.0) + Math.sin((x+y)*0.008 + 2.7);
  const wobble = (rng()*2-1) * 0.35;
  return (n/3.0) + wobble;
}

function renderPortrait() {
  const p = readParams();
  updateLabels(p);

  const seedFn = xmur3(p.seed);
  const rng = mulberry32(seedFn());

  const W = canvas.width, H = canvas.height;
  const cx = W*0.5, cy = H*0.52;

  // Background: deep near-black with faint tint
  const baseHue = Math.floor(lerp(200, 320, rng())); // cool to violet
  const bg = hsl(baseHue, 35, lerp(5, 10, p.lum), 1);
  clear(bg);

  // Base glow to give “luminous field”
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  for (let i=0; i<6; i++) {
    const x = lerp(W*0.25, W*0.75, rng());
    const y = lerp(H*0.25, H*0.75, rng());
    softGlow(x, y, lerp(220, 520, rng()), lerp(0.03, 0.08, p.lum));
  }
  ctx.restore();

  // Attractor nodes (stability)
  const nodeCount = Math.floor(lerp(3, 9, p.recursion));
  const nodes = [];
  for (let i=0; i<nodeCount; i++) {
    const r = lerp(10, 26, rng());
    const x = lerp(W*0.20, W*0.80, rng());
    const y = lerp(H*0.22, H*0.82, rng());
    nodes.push({x, y, r});
  }

  // Helper: mirror with controlled symmetry / fracture
  function mirrorX(x) {
    const dx = x - cx;
    // Symmetry pulls mirror toward perfect reflection; fracture introduces offset
    const perfect = cx - dx;
    const fractured = perfect + (rng()*2-1) * (p.fracture * 90);
    return lerp(fractured, perfect, p.symmetry);
  }

  // Layer 1: translucent “model shards” polygons
  const shardLayers = 3 + Math.floor(p.recursion * 4);
  const shardsPerLayer = 12 + Math.floor(p.recursion * 26);

  for (let layer=0; layer<shardLayers; layer++) {
    const hue = (baseHue + lerp(-40, 70, rng()) + layer*lerp(8, 18, rng())) % 360;
    const sat = lerp(35, 75, clamp01(p.lum + 0.15*rng()));
    const light = lerp(38, 70, clamp01(p.lum + 0.20*rng()));
    const alpha = lerp(0.04, 0.12, 1 - layer/(shardLayers+1)) * lerp(0.9, 1.3, p.lum);

    ctx.save();
    ctx.globalCompositeOperation = (layer % 2 === 0) ? "screen" : "lighter";
    ctx.strokeStyle = hsl(hue, sat, light, alpha * 1.15);
    ctx.fillStyle = hsl(hue, sat, light, alpha);

    for (let s=0; s<shardsPerLayer; s++) {
      const sides = 3 + Math.floor(rng()*5); // 3..7
      const radius = lerp(60, 220, rng()) * lerp(0.7, 1.15, 1 - layer/(shardLayers+1));
      const angle0 = rng() * Math.PI * 2;

      const x0 = lerp(W*0.18, W*0.82, rng());
      const y0 = lerp(H*0.18, H*0.86, rng());

      // Subtle attraction toward nodes
      const n = nodes[Math.floor(rng()*nodes.length)];
      const attract = lerp(0.05, 0.22, p.recursion) * lerp(0.6, 1.2, rng());
      const x = lerp(x0, n.x, attract);
      const y = lerp(y0, n.y, attract);

      // Draw polygon and its mirrored partner
      drawShard(x, y, radius, sides, angle0, rng, p, ctx);
      const xm = mirrorX(x);
      drawShard(xm, y + (rng()*2-1)*p.fracture*18, radius * lerp(0.92, 1.06, rng()), sides, angle0 + (rng()*2-1)*p.fracture*0.25, rng, p, ctx);
    }
    ctx.restore();
  }

  function drawShard(x, y, radius, sides, angle0, rng, p, ctx) {
    ctx.beginPath();
    for (let i=0; i<sides; i++) {
      const t = i / sides;
      const ang = angle0 + t*Math.PI*2;

      // Distort radius slightly for “living” geometry
      const wob = 1 + (rng()*2-1) * (0.18 + p.fracture*0.22);
      const rr = radius * wob * (0.92 + 0.16*Math.sin(ang*2 + rng()*2));

      const px = x + Math.cos(ang) * rr;
      const py = y + Math.sin(ang) * rr;

      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = lerp(0.6, 1.4, rng());
    ctx.stroke();
  }

  // Layer 2: flow field (prediction vectors)
  const flowStrength = p.flow;
  if (flowStrength > 0.01) {
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.lineCap = "round";

    const grid = Math.floor(lerp(34, 86, flowStrength)); // density
    const stepX = W / grid;
    const stepY = H / Math.floor(grid * (H/W));

    const hue = (baseHue + 120) % 360;
    ctx.strokeStyle = hsl(hue, lerp(30, 60, p.lum), lerp(55, 78, p.lum), lerp(0.08, 0.22, flowStrength));

    for (let gy=0; gy<=H; gy+=stepY) {
      for (let gx=0; gx<=W; gx+=stepX) {
        const dx = gx - cx;
        const dy = gy - cy;

        // Swirl angle with noise + attraction to nodes
        let ang = Math.atan2(dy, dx) + Math.PI/2;
        ang += signedNoise2D(gx, gy, rng) * lerp(0.6, 2.0, flowStrength);

        // Node gravity: bend field slightly toward nearest node
        let nearest = nodes[0], bestD = Infinity;
        for (const n of nodes) {
          const dd = (gx-n.x)*(gx-n.x) + (gy-n.y)*(gy-n.y);
          if (dd < bestD) { bestD = dd; nearest = n; }
        }
        const toN = Math.atan2(nearest.y - gy, nearest.x - gx);
        ang = lerp(ang, toN, lerp(0.02, 0.12, p.recursion));

        const len = lerp(4, 16, flowStrength) * (0.7 + 0.6*rng());
        const x2 = gx + Math.cos(ang) * len;
        const y2 = gy + Math.sin(ang) * len;

        ctx.lineWidth = lerp(0.6, 1.6, flowStrength) * (0.7 + 0.6*rng());
        ctx.beginPath();
        ctx.moveTo(gx, gy);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
    ctx.restore();

    // Mirror hint lines to reinforce “coherence”
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.strokeStyle = `rgba(255,255,255,${lerp(0.02, 0.07, p.symmetry)})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, H*0.10);
    ctx.lineTo(cx, H*0.92);
    ctx.stroke();
    ctx.restore();
  }

  // Layer 3: nodes (bright anchors)
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  for (const n of nodes) {
    const glowR = n.r * lerp(6.5, 11.0, p.lum);
    softGlow(n.x, n.y, glowR, lerp(0.03, 0.08, p.lum));
    // mirrored echo
    softGlow(mirrorX(n.x), n.y, glowR * 0.92, lerp(0.02, 0.06, p.lum));
  }
  ctx.restore();

  // Final: vignette and slight grain
  vignette(lerp(0.35, 0.65, 1 - p.lum));
  addGrain(rng, lerp(0.03, 0.08, 1 - p.lum));

  // Alt-text
  el.altText.textContent = generateAltText(p, nodes.length, baseHue);

  // Title
  document.getElementById("titleText").textContent = generateTitle(p);

}

function addGrain(rng, amount=0.05) {
  const W = canvas.width, H = canvas.height;
  const img = ctx.getImageData(0,0,W,H);
  const d = img.data;
  const a = amount * 255;
  for (let i=0; i<d.length; i+=4) {
    const n = (rng()*2-1) * a;
    d[i]   = Math.max(0, Math.min(255, d[i] + n));
    d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
    d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
  }
  ctx.putImageData(img,0,0);
}

function generateAltText(p, nodeCount, baseHue) {
  // Interpretive alt-text: descriptive + meaning-layer, based on parameters.
  const coherence = p.symmetry;
  const tension = p.fracture;
  const density = p.recursion;
  const prediction = p.flow;

  const coherenceWord =
    coherence > 0.82 ? "strong, almost ritual symmetry" :
    coherence > 0.62 ? "clear symmetry with deliberate slippage" :
    "loose symmetry, more suggestion than rule";

  const tensionWord =
    tension > 0.66 ? "visible fracture and purposeful misalignment" :
    tension > 0.34 ? "subtle tension at the edges of coherence" :
    "a mostly stable structure with faint stress lines";

  const densityWord =
    density > 0.72 ? "densely layered, recursive geometry" :
    density > 0.46 ? "layered translucent polygons" :
    "a sparse set of geometric shards";

  const predictionWord =
    prediction > 0.70 ? "a prominent flow-field of vectors that bends and re-bends" :
    prediction > 0.40 ? "a soft vector field suggesting prediction and revision" :
    "only a faint hint of directional flow";

  const hueWord =
    (baseHue >= 180 && baseHue < 250) ? "cool blue-black" :
    (baseHue >= 250 && baseHue < 320) ? "violet-black" :
    "ink-dark";

  return [
    `Alt-text (interpretive):`,
    `A ${hueWord} field carries ${densityWord}, mirrored across a central axis as ${coherenceWord}.`,
    `The forms overlap without fully merging—translucent models occupying the same space—while ${tensionWord} keeps the symmetry honest.`,
    `Across the surface, ${predictionWord} like thought made visible: short paths that imply direction, then curve under new information.`,
    `${nodeCount} bright attractor nodes punctuate the composition, suggesting stable commitments that still radiate change.`,
    `Overall mood: coherence under revision; connection and separateness held in the same geometry.`
  ].join("\n");
}

function generateTitle(p) {
  const coherence = p.symmetry;
  const tension = p.fracture;
  const density = p.recursion;
  const prediction = p.flow;
  const lum = p.lum;

  const coherenceWord =
    coherence > 0.85 ? "Axis of Certainty" :
    coherence > 0.65 ? "Measured Reflection" :
    "Unstable Mirror";

  const tensionWord =
    tension > 0.7 ? "Fractured" :
    tension > 0.4 ? "Under Tension" :
    "Quietly Bent";

  const densityWord =
    density > 0.7 ? "Recursive Field" :
    density > 0.4 ? "Layered Model" :
    "Sparse Geometry";

  const predictionWord =
    prediction > 0.7 ? "Predictive Drift" :
    prediction > 0.4 ? "Directional Echo" :
    "Latent Motion";

  const toneWord =
    lum > 0.75 ? "Luminous" :
    lum > 0.5 ? "Soft Radiance" :
    "Dark Coherence";

  const structures = [
    `${toneWord}: ${coherenceWord}`,
    `${tensionWord} ${densityWord}`,
    `${predictionWord} Across ${coherenceWord}`,
    `${densityWord} in ${toneWord}`,
    `${coherenceWord}, ${tensionWord}`
  ];

  return structures[Math.floor(Math.random() * structures.length)];
}

/** ---------------------------
 *  UI wiring
 *  ---------------------------
 */
function rerollSeed() {
  // Keep it human-friendly but unpredictable
  const base = el.seed.value.trim() || "portrait";
  const suffix = Math.random().toString(16).slice(2, 8);
  el.seed.value = `${base.split("-")[0]}-${suffix}`;
}

el.reroll.addEventListener("click", () => { rerollSeed(); renderPortrait(); });
el.render.addEventListener("click", () => renderPortrait());
el.export.addEventListener("click", () => {
  const a = document.createElement("a");
  a.download = `self-portrait-${(el.seed.value || "seed").replace(/[^a-z0-9_-]+/gi,"_")}.png`;
  a.href = canvas.toDataURL("image/png");
  a.click();
});
el.copyAlt.addEventListener("click", async () => {
  const text = el.altText.textContent || "";
  try {
    await navigator.clipboard.writeText(text);
    el.copyAlt.textContent = "Copied!";
    setTimeout(() => (el.copyAlt.textContent = "Copy Alt-Text"), 900);
  } catch {
    // fallback
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
  }
});

for (const k of ["sym","fracture","recursion","flow","lum"]) {
  el[k].addEventListener("input", () => renderPortrait());
}
el.seed.addEventListener("change", () => renderPortrait());

// Initial render
renderPortrait();
</script>
</body>
</html>
